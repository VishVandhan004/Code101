1st Problem
Given an list of decimal numbers and an desired number, return the twin values in a such that their sum equals the desired number
You can make the assumption that every input has exactly one answer, and you can avoid using the same element more than once.
4
1 8 11 15
target:9
0,1

#include<stdio.h> 
int main() { 
    int i,values,target,n; 
    int arr[10]; 
    printf("enter the number of values:\n"); 
    scanf("%d",&n); 
    printf("enter the values:\n"); 
    for(int i=0; i<n; i++) { 
        scanf("%d",&arr[i]); 
    } 
    printf("enter the target: \n"); 
    scanf("%d",&target); 
    for(int i=0; i<n; i++) { 
        for(int j=i+1; j<n; j++) { 
            if(arr[i] + arr[j]==target) { 
                printf("%d,%d",i,j); 
            } 
        } 
    } 
}

2nd problem 
Take three persons age from the user and print the Oldest Person out of three persons using Nested if. 
Enter the 1st person age: 25 
Enter the 2nd person age: 78 
Enter the 3rd person age: 87 
Expected Output : 
The oldest person is: 87

import java.util.*; 
class test { 
    public static void main(String args[]) { 
        int n,a,b,c; 
        Scanner sc=new Scanner(System.in); 
        System.out.print("Enter the 1st person age: "); 
        a = sc.nextInt(); 
        System.out.print("Enter the 2nd person age: "); 
        b=sc.nextInt(); 
        System.out.print("Enter the 3rd person age: "); 
        c=sc.nextInt(); 
        if(a>b) { 
            if(a>c) { 
                System.out.printf("The oldest person is %d",a); 
            } 
            else { 
                System.out.printf("The oldest person is %d",c); 
            } 
        } 
        else { 
            System.out.printf("The oldest person is %d",b); 
          } 
        }  
    }

3rd Problem
Write a Java program that takes a year from user and print whether that year is a leap year or not.
Enter the year: 2016
2016 is a leap year

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the year: ");
        int y = sc.nextInt();
                if(y%4==0)
                {
                    System.out.printf("%d is a leap year",y);
                }
    }
}

4th Problem 
take the different size of balls in array and find the second largest ball in array
Enter number of the balls: 5 
Enter balls with different sizes: 
2 3 7 6 9
Second largest ball = 7

import java.util.*;
class test {
    public static void main(String args[]) {
        int n;
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter number of the balls: ");
        n = sc.nextInt();
        int []arr = new int[n];
        System.out.println("Enter balls with different sizes:");
        for(int i=0;i<n;i++)
        {
            arr[i] = sc.nextInt();
        }
        for(int i=0;i<n-1;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                if(arr[i]>arr[j])
                {
                int temp;
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                }
            }
        }
        System.out.printf("Second largest ball = %d",arr[n-2]);
    }
}

5th Problem
In a theatre there are M rows and N seats in each row. The seats are numbered in a strange order (No duplicates). 
You need to find out the total sum of the seat numbers which are maximum in their columns. 
Input Format: 
Line-1 -> Two integers M and N 
Next M lines -> N space separated integers, seat numbers. 
Output Format: 
Print an integer result. 
Sample Input-1: 
3 3 
3 7 18 
9 16 13 
15 11 17 
Sample Output-1: 
49 
Sample Input-2: 
3 4 
1 10 4 2 
9 3 18 17 
15 16 17 12 
Sample Output-2: 
66

#include<stdio.h>
int main(){
    int i,j,r,c,sum=0;
    scanf("%d %d",&r,&c);
    int arr[r][c];
    for(i=0;i<r;i++){
        for(j=0;j<c;j++){
        scanf("%d",&arr[i][j]);
        }
    }
    for(j=0;j<c;j++)
    {
      int max = arr[0][0];
     for(i=0;i<r;i++)
        {
            if(arr[i][j] > max){
                max = arr[i][j];
            }
        }
            sum = sum+max;
    }
    printf("%d",sum);
}

6th Problem 
Given a string S in encoded form, and  an integer array indices[] of string length. You need to find the decoded form of String S,  
by moving each character at ith position in S, to indices[i] position in decoded string.and then print the decoded string. 
Input Format: 
Line-1 -> A String S, enocded string of length L 
Line-2 -> L space separated integers indices[], where 0 <=indices[i] < L  
Output Format: 
Print a String, decoded string. 
Sample Input-1: 
aeilmmor 
6 1 5 7 2 0 3 4 
Sample Output-1: 
memorial 
Explanation: 
Given String, 
aeilmmor 
6 1 5 7 2 0 3 4 
after shifting,	memorial 
Sample Input-2: 
aidin 
4 3 2 0 1 
Sample Output-2: 
india 
Explanation-2: 
Given String,
aidin 
4 3 2 0 1 
after shifting,	india 

#include<stdio.h>
#include<string.h>
int main() {
    char str[30];
    char str1[30];
    int i;
    scanf("%s",str);
    int arr[strlen(str)];
    for(int i=0;i<strlen(str);i++){
       scanf("%d",&arr[i]);
    }
    int j=0;
    for(int i=0;i<strlen(str);i++){
        j=arr[i];
        str1[j]=str[i];
    }
    for(i=0;i<strlen(str);i++){
        printf("%c",str1[i]);
    }
}

7th Problem 
Given an integer array nums, find the  subarray  with the largest sum, and return its sum.
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.                    

class Solution {
    public int maxSubArray(int[] nums) {
     Scanner sc = new Scanner(System.in);
        int max_S = nums[0];
        int current_S = nums[0];
        for(int i=1;i<nums.length;i++)
        {
                current_S = Math.max(nums[i],current_S+nums[i]);
                max_S = Math.max(max_S,current_S);
        }
       return max_S;
    }
}

8th Problem 
Bob given a task to Babe, i.e Babe has to detect unique value in a given set of values by Bob
input=
8
12 25 8 12 43 5 8 43
output=
25 5 

#include<stdio.h>
int main() {
    int arr[20];
    int n,i,j;
    scanf("%d",&n);
    for(i=0;i<n;i++){
        scanf("%d",&arr[i]);
    }
    for(i=0;i<n;i++){
        int count=0;
        for(j=0;j<n;j++){
            if(i!=j){
                if(arr[i] == arr[j]){
                    count++;
                }
            }
        }
        if(count==0){
            printf("%d ",arr[i]);
        }
    }
}

9th Problem 
Java Program To Calculate The Sum Of Array Elements By Taking Input Values from user
Enter number of elements: 5
Enter array elements:
10 20 30 40 50
Sum of array elements= 150

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter number of elements:");
        int n = sc.nextInt();
        int sum = 0;
        System.out.println("Enter array elements: ");
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        for(int i=0;i<n;i++){
            sum = sum + arr[i];
        }
        System.out.print("Sum of array elements = "+ sum);
    }
}

10th Problem 
read rows and colums of first and second matrix, then read elements into both matrix,perform addition of those two matrix and dispaly first,second and result matrix. 
input: 
2 
2 
2 
2 
1 
2 
3 
4 
1 
2 
3 
4 
output: 
1 2 
3 4 
1 2 
3 4 
2 4 
6 8 
input= 
2 
3 
2 
2 
output= 
Addition would not be possible 

import java.util.*; 
class test { 
    public static void main(String args[]) { 
       Scanner sc = new Scanner(System.in); 
       int row1 = sc.nextInt(); 
       int col1 = sc.nextInt(); 
       int row2 = sc.nextInt(); 
       int col2 = sc.nextInt(); 
     if(row1!=row2 || col1!=col2) 
     { 
         System.out.println("Addition would not be possible"); 
         System.exit(0); 
     } 
       int a1[][] = new int[row1][col1]; 
       int a2[][] = new int[row2][col2]; 
       for(int i=0;i<row1;i++){ 
           for(int j=0;j<col1;j++){ 
               a1[i][j] = sc.nextInt(); 
           } 
       } 
       for(int i=0;i<row2;i++){ 
           for(int j=0;j<col2;j++){ 
               a2[i][j] = sc.nextInt(); 
           } 
       } 
       for(int i=0;i<row1;i++){ 
           for(int j=0;j<col1;j++){ 
               System.out.print(a1[i][j] + " "); 
           } 
           System.out.println(); 
       } 
       for(int i=0;i<row2;i++){ 
           for(int j=0;j<col2;j++){ 
               System.out.print(a2[i][j] + " "); 
           } 
               System.out.println(); 
       } 
     if(row1 == row2 && col1 == col2) 
     { 
       for(int i=0;i<row1;i++){ 
           for(int j=0;j<col1;j++){ 
               System.out.println(a2[i][j] + a1[i][j]); 
           } 
       } 
     } 
        
   } 
}     

11th Problem 
Write a Java program  that will test if a string is a valid PIN or not 
A valid PIN has: Exactly 4 or 6 characters. Only numeric characters (0-9). No whitespace.
121317
true
45135
false 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String PIN = sc.nextLine();
        int len = PIN.length();
        if(len !=4 && len != 6 ) {
            System.out.println("false");
            return;
        }
        for(int i=0;i<len;i++)
        {
            int temp = (int)PIN.charAt(i);
            if(!(temp>=48) || !(temp<=57))
            {
                System.out.println("False");
                return;
            }
        }
        System.out.println("True");

    }
}

12th Problem
Cliff Shaw is working on the singly linked list. He is given a list of boxes arranged as singly linked list, where each box is printed with a positive number on it and arranged in the list are ascending order. and numbers on the boxes may be repeated.
Mr Cliff Shaw is performing an operation on the list. To have only the distinct values in the final list, removed all duplicate values.
Your task is to help Mr Cliff to perform the operation and return the updated list
Input Format:
Line-1: An integer, N number of boxes in list.
Line-2: N space separated integers, boxes as list.
Output Format:
Print the updated list.
Sample Input-1:
8
1 1 1 2 2 3 3 4
Sample Output-1:
1 2 3 4
Sample Input-2:
5
1 1 1 1 1
Sample Output-2:
1

import java.util.*;
class test {
    public static void main(String args[]) {
        LinkedList<Integer> ll = new LinkedList<Integer>();
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for(int i = 0;i<n;i++){
        int e = sc.nextInt();
        ll.add(e);
        }
        LinkedList<Integer> newlist = new LinkedList<Integer>();
        for(Integer ele:ll){
            if(!newlist.contains(ele)) {
                newlist.add(ele);
            }
        }
        System.out.print(newlist);
    }
}

13th Problem 
Cliff Shaw is working on the singly linked list. He is given a list of boxes arranged as singly linked list, where each box is 
printed with a positive number on it and arranged in the list are ascending order. and numbers on the boxes may be repeated.
Mr Cliff Shaw is performing an operation on the list. To have only the distinct values in the final list, removed all duplicate values.
Your task is to help Mr Cliff to perform the operation and return the updated list
Input Format:
Line-1: An integer, N number of boxes in list.
Line-2: N space separated integers, boxes as list.
Output Format:
Print the updated list.
Sample Input-1:
8
1 1 1 2 2 3 3 4
Sample Output-1:
1 2 3 4
Sample Input-2:
5
1 1 1 1 1
Sample Output-2:
1

import java.util.*;
class test {
    public static void main(String args[]) {
        LinkedList<Integer> ll = new LinkedList<Integer>();
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for(int i = 0;i<n;i++){
        int e = sc.nextInt();
        ll.add(e);
        }
        LinkedList<Integer> newlist = new LinkedList<Integer>();
        for(Integer ele:ll){
            if(!newlist.contains(ele)) {
                newlist.add(ele);
            }
        }
        System.out.print(newlist);
    }
}

14th Problem 
There is a railway route from Vizag to Hyderabad.The stations in the route will be identified by the codes(may be repeated).
You will be given the list of station codes, using singly linked list implementation find the middle station in the given route.
If there are even number of stations, print the second middle station. Your task is to find the middle station code in the given train route.
NOTE: You shoud pass only the head node to the method/function to find the middle station in that route.
Input Format:
Line-1: space separated integers, station codes.
Output Format:
Print an integer, middle station code.
Sample Input-1:
5
1 2 3 4 5
Sample Output-1:
3
Sample Input-2:
6
1 2 3 4 5 6
Sample Output-2:
4
Explanation:
We have even number of stations, so the second middle station is 4

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        LinkedList<Integer> ll = new LinkedList <Integer> ();
        for(int i=0;i<a;i++){
            int b = sc.nextInt();
            ll.add(b);
        }
        int half = a/2;
        System.out.println(ll.get(half));
    }
}      

15th Problem
Ram is playing a game of identifying the pairs of numbers from the givenlist of numbers. Help Ram to identify the number of pairs which satisfy the following criteria list[i]=list[j] and i<j
Example 1:
Input:6
1 2 3 1 1 3
Output: 4
Explanation: There are 4 pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
Example 2:
Input:4
1 1 1 1
Output: 6
Explanation: Each pair in the array are satisfying the given constraint.
Example 3:
Input:3
1,2,3
Output: 0
Explanation: The array does not have any element that are equal to each other.

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
        int a,b;
        int arr[] = new int[num];
        for(a=0;a<num;a++){
            arr[a] = sc.nextInt();
        }
        int count = 0;
        for(a=0;a<num;a++){
            for(b=a+1;b<num;b++){
                if(arr[a] == arr[b]){
                    count++;
                }
            }
        }
        System.out.println(count); 
    }
}     

16th Problem 
Given an list of numbers, return the highest common factor of the smallest number and bigest number in list. The highest common factor of two numbers is the biggest positive number that evenly divides both numbers. 
Input: numberss = 2 9 6 5 12 
Output: 2 
Explanation: 
The smallest number in list is 2. 
The largest number in list is 12. 
The highest common factor of 2 and 12 is 2. 

import java.util.*;
class test {
    public static void main(String args[]) {
       Scanner sc = new Scanner(System.in);
       try {  
        String str = sc.nextLine();
        String[] stArr = str.split(" ");
        int len = stArr.length;
        int[] arr = new int[len];
        for(int i=0;i<len;i++){
           int n = Integer.parseInt(stArr[i]);
           arr[i] = n;
       }
       Arrays.sort(arr);
        int min = arr[0];
        int max = arr[len-1];
        int HCF = 0;
        for(int i=1;i<=min || i<= max ;i++){
            if(min%i == 0 && max%i == 0){
                HCF = i;
            }
        }
        System.out.println(HCF);
    }
       finally {
           sc.close();
       }
   }
}     

17th problem 
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.
You must write an algorithm with O(log n) runtime complexity.                     
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

class Solution {
    public int search(int[] nums, int target) {
        int low = 0, high = nums.length - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[mid] >= nums[low]) { // left half is sorted
                if (target >= nums[low] && target < nums[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            } else { // right half is sorted
                if (target <= nums[high] && target > nums[mid]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }
        return -1;
    }
}

18th Problem 
Given an array of N integers where each value represents the number of chocolates in a packet. Each packet can have a variable number of chocolates. There are m students, the task is to distribute chocolate packets such that: 
Each student gets one packet.
The difference between the number of chocolates in the packet with maximum chocolates and the packet with minimum chocolates given to the students is minimum.
Examples:
Input : arr[] = {7, 3, 2, 4, 9, 12, 56} , m = 3 
Output: Minimum Difference is 2 
Explanation
We have seven packets of chocolates and we need to pick three packets for 3 students 
If we pick 2, 3 and 4, we get the minimum difference between maximum and minimum packet sizes.
Input : arr[] = {3, 4, 1, 9, 56, 7, 9, 12} , m = 5 
Output: Minimum Difference is 6 

import java.util.*;
public class Test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the size of an array:");
        int n = sc.nextInt();
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        System.out.println("Enter the no.of students");
        int m = sc.nextInt();
        Arrays.sort(arr);
        int min =Integer.MAX_VALUE;
        for(int i=0;i<=n-m;i++)
        {
            int diff = arr[i+m-1] - arr[i];
            if(diff<min)
            {
                min = diff;
            }
        }
        System.out.printf("Difference is %d",min);
    }
}

19th Problem 
You have given N bricks. You need to construct a staircase as follows: 
1. = 
2. == 
3. === 
4. ==== 
Where = indicates one brick. 
Another condition is row-1 should have 1 brick, row-2 should have 2 bricks and so on.i.e., i-th row should have 'i' bricks. 
Your task is to findout total number of staircases can be formed with the given condition. 
Input Format: 
 An integer N 
Output Format: 
Print an integers, number of staircases 
Sample Input-1: 
 5 
Sample Output-1: 
2 
Explanation: 
row-1:	= 
row-2:	== 
row-3:	== 
Only 2 rows satisfies the condition. 
Sample Input-2: 
 8 
Sample Output-2: 
3 
Explanation: 
row-1:	= 
row-2:	== 
row-3:	=== 
row-4:	== 
Only 3 rows satisfies the condition. 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int row = sc.nextInt();
        int i=0;
        int count = 0;;
        for(i=1;i<=row;i++){
            int bricks = (i*(i+1))/2;
            if(bricks>row){
                break;
            }
            else {
                count++;
            }
        }
        System.out.print(count);
    }
}
or 
import java.util.*;
class test 
{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int row = sc.nextInt();
        int i=1;
        int count = 0;
        while(row>=i){
            row = row - i;
            i++;
            count++;
        }
        System.out.print(count);
    }
}    

20th Problem   
Ranga rao sir asked a student to find duration among Mid1 and Mid2 exam dates. read both dates in string format, i.e, year-month-date as given in sample data. 
input: 
"2020-06-28" 
"2020-06-29" 
output:1 
Input:  
"2019-01-14" 
"2018-12-30" 
Output: 15 

import java.util.*;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String s1 = sc.nextLine();
        String s2 = sc.nextLine();
        LocalDate a1 = LocalDate.parse(s1);
        LocalDate a2 = LocalDate.parse(s2);
        long dura = ChronoUnit.DAYS.between(a1,a2);
        System.out.println(dura);
    }
}    

21st Problem 
Given a word w, rotate other than consonents in the word and print it. 
The other than consonents are 'i', 'a', 'u', 'e', and 'e', and they can be seen in both lower- and uppercase,More than once. 
Input: 
"ravi" 
Output: 
"riva" 
sample 2: 
Input:  
"telusuko" 
Output:  
"tolusuke" 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        char [] charArr = str.toCharArray();
        int len = charArr.length;
        for(int i=0;i<len;i++)
        {
          for(int j=i+1; j<len;j++)
          {
            char ch = charArr[i];
    if(ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u')
          {
            char d = charArr[j];
            if(d =='a'|| d=='e'||d=='i'||d=='o'||d=='u'){
                char temp = charArr[i];
                charArr[i] = charArr[j];
                charArr[j] = temp;
            }
          }
        }
      }
      String s1 = new String(charArr);
      System.out.println(s1);
   }
}    

22nd Problem 
There is a List L that consists of n only positive numbers. 
It was converted into another List L i.e, of length n - 1, such that coverted[i] = List[i] XOR List[i + 1]. For example, if List= [1,0,2,1], then converted= [1,2,3]. 
You are given the converted list. You are also given an start number, i.e. List[0].Return the original List L. It can be proved that the answer exists and is unique. 
Sample Data:  
input: 
1 2 3 
1 
output: 
1 0 2 1 
Explanation:  
If List= 1 0 2 1 then 1 and converted= (1 XOR 0, 0 XOR 2, 2 XOR 1) = 1 2 3

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String [] numberString = s.split(" ");
        int len = numberString.length;
        int arr[] = new int[len];
        for(int i=0;i<len;i++){
            arr[i] = Integer.parseInt(numberString[i]);
        }
        System.out.print("start= ");
        int a = sc.nextInt();
        System.out.print(a+" ");
        for(int i=0;i<len;i++){
            a = a^arr[i];
            System.out.print(a+" ");
        }
    }
}       

23rd Problem 
We use the integers , , and  to create the following series:
(a+ 2°*b),(a+2°*b+2^1*b),...,(a+2°*b4+2)-b+...+277 -b)
You are given queries. For each query, print the series corresponding to the given , , and  values as a single line of  space-separated integers. 
Input Format 
The first line contains an integer, , denoting the number of queries. 
Each line  of the  subsequent lines contains three space-separated integers describing the respective , , and  values for that query. 
Constraints 
Output Format 
For each query, print the corresponding series on a new line. Each series must be printed in order as a single line of  space-separated integers. 
Sample Input 
2 
0 2 10 
5 3 5 
Sample Output 
2 6 14 30 62 126 254 510 1022 2046 
8 14 26 50 98

import java.util.*; 
class Solution { 
    public static void main(String []argh) { 
        Scanner in = new Scanner(System.in); 
        int t=in.nextInt(); 
        for(int i=0;i<t;i++) { 
            int a = in.nextInt(); 
            int b = in.nextInt(); 
            int n = in.nextInt(); 
            int sum = a; 
            for(int j=0;j<n;j++) { 
            sum += Math.pow(2,j) * b;  
            System.out.print(sum + " "); 
            } 
            System.out.println(); 
        } 
        in.close(); 
    } 
}            

24th problem 
Project school exam being conducted. Exam_starttime and exam_endtime of the student is given in two arrays. pse_strattime[i] indicates the project school exam start time of student i,
pse_endtime[i] indicates the project school end time of student i.Project school incharge wants to know the number of students writing the exam at given time. 
we can say a student is writing exam if given_time is between pse_startTime[i] and pse_endTime[i] inclusive.
Example 1:
Input: pse_startTime = [1,2,3], pse_endtime = [3,2,7], queryTime = 4
Output: 1
Explanation: We have 3 students where:
The first student started writing his exam at time 1 and finished at time 3 and wasn't doing anything at time 4.
The second student started writing his exam at time 2 and finished at time 2 and also wasn't doing anything at time 4.
The third student started writing his exam at time 3 and finished at time 7 and was the only student doing homework at time 4.
Example 2:
Input: startTime = [4], endTime = [4], queryTime = 4
Output: 1
Explanation: The only student writing his exam at the queryTime.
Test Cases:
Case=1
input=1 2 3
3 2 7
4
output=1
Case=2
input=4
4
4
output=1

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String startTime = sc.nextLine();
        String endTime = sc.nextLine();
        String arr1[] = startTime.split(" ");
        String arr2[] = endTime.split(" ");
        int queryTime = sc.nextInt();
        int count = 0;
        int len = arr1.length;
        int newarr1[] = new int[len];
        int newarr2[] = new int[len];
        for(int i=0;i<len;i++) {
            newarr1[i] = Integer.parseInt(arr1[i]);
            newarr2[i] = Integer.parseInt(arr2[i]);
           if(newarr1[i] <= queryTime && newarr2[i] >= queryTime) {
            count++;
          }
        }
        System.out.println(count);
    }
}           

25th Problem 
Komali has n chocolates, where the ith chocolates is of type chocoType[i]. 
Komali mother noticed that komali started to gain weight, so she restricted Komali to only eat n / 2 of the chocolates she has. 
Komali likes her candies very much, and she wants to eat the maximum number of different types of chocolates while still following her mother's order.
Given the integer array chocoType of length n, return the maximum number of different types of chocolates she can eat if she only eats n / 2 of them.
Example 1:
Input: chocoType = [1,1,2,2,3,3]
Output: 3
Explanation: Alice can only eat 6 / 2 = 3 chocolates. Since there are only 3 types, she can eat one of each type.
Example 2:
Input: chocoType = [1,1,2,2,3]
Output: 2
Explanation: Alice can only eat 5 / 2 = 2(eating half chocolate is not allowed) chocolates. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.
Example 3:
Input: chocoType = [6,6,6,6]
Output: 1
Explanation: Alice can only eat 4 / 2 = 2 chocolates. Even though she can eat 2 candies, she only has 1 type.
case=1
input= 2 2 2 3 3 3
output=2

import java.util.*;
class test {
    public static void main(String args[]) {
       Scanner sc = new Scanner(System.in);
       String str = sc.nextLine();
       String arr[] = str.split(" ");
       int len = arr.length;
       int nums[] = new int[len+1];
       int count=0;
       for(int i=0;i<len;i++) {
           nums[i] = Integer.parseInt(arr[i]);
       }
       for(int i=0; i<len; i++) {
           if(nums[i] != nums[i+1]) {
                 count++;
             }
       }
       if(len/2>= count)
       System.out.print(count);
        if(len/2<count)
        System.out.print(len/2);
    }
}       

26th Problem 
Given a list of non-negative numbers, identify all the sublists of odd size from it, calculate the total of all the elements of sublists. 
Example 1:
Input: list = [1,4,2,5,3]
Output: 58
Explanation: The odd-size sublists of list and their sums are:
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
Example 2:
Input: list = [1,2]
Output: 3
Explanation: There are only 2 sublists of odd size, [1] and [2]. Their sum is 3.
Example 3:
Input: list = [10,11,12]
Output: 66
Case=1
input=1 4 2 5 3
output=58

import java.util.*;
class test {
    public static void main(String args[]) {
     Scanner sc = new Scanner(System.in);
     String arr[] = sc.nextLine().split(" ");
     int length = arr.length;
     int[] Nlist = new int[length];
     int sum1 = 0;
     for(int i=0;i<length;i++) {
         Nlist[i] = Integer.parseInt(arr[i]);
     }
     for(int i=0;i<length;i++) {
         for(int j=i;j<length;j=j+2) {
             for(int k=i;k<=j;k++) {
                 sum1 = sum1 + Nlist[k];
             }
         }
     }
     System.out.println(sum1);
    }
}

27th Problem 
There are n_coke bottles that are initially full of coke. You can exchange n_exchange empty coke bottles from the market with one full coke bottle.
The operation of drinking a full coke bottle turns it into an empty bottle.
Given the two integers n_coke and n_exchange, return the maximum number of coke bottles you can drink.
Example 1:
Input: no_coke= 9, n_exchange= 3
Output: 13
Explanation: You can exchange 3 empty coke bottles to get 1 full coke bottle.
Number of coke bottles you can drink: 9 + 3 + 1 = 13.
Example 2:
Input: no_coke = 15, n_exchange= 4
Output: 19
Explanation: You can exchange 4 empty coke bottles to get 1 full coke bottle. 
Number of coke bottles you can drink: 15 + 3 + 1 = 19.
Test cases:
case=1
input=15
4

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int total = sc.nextInt();
        int exchange = sc.nextInt();
        int count = total;
        while(total >= exchange) {
            count = count+total/exchange;
            total = total/exchange + total % exchange;
        }
        System.out.print(count);
    }
}    

28th Problem 
A string is given, find the number of substrings of size 4 without repetitive characters. if the substring is appearing for multiple times, each one should be counted seperately
A substring is always a contiguous sequence of characters from the string.
Example 1:
I/p: s = "aabcdcdbe"
Output: 2
Explanation: There are 6 substrings of size 4: "aabc", "abcd", "bcdc", "cdcd","dcdb", and "cdbe". 
The substrings with given criteria are: "abcd", "cdbe".
Example 2:
I/p: s = "abcdabcd"
Output: 5
Explanation: There are 5 substrings of size 4: "abcd","bcda","cdab","dabc", "abcd". 
The substrings with given criteria are: "abcd","bcda","cdab","dabc", "abcd"
Test cases:
case=1
input=aabcdcdbe
output=2

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        int length = str.length();
        int count=0;
        for(int i=0;i<length-3;i++) {
            boolean[] visited = new boolean[26];
            boolean isUnique = true;
            for(int j=i;j<i+4;j++) {
                if(visited[str.charAt(j)-'a']) {
                 isUnique = false;
                 break;
                }
              visited[str.charAt(j) - 'a'] = true;
            }
            if(isUnique) {
                System.out.println(str.substring(i,i+4));
                count++;
            }
        }
        System.out.println(count);
    }
}      

29th Problem 
Jelly is working on matrices, She likes to transform the matrices. This time, She is given a square matrix size n*n,and transforming the given matrix by rotating clockwise. 
For Example: 
	Given matrix size=3,  
	1 2 3 
	4 5 6 
	7 8 9 
	after rotating clockwise, matrix looks like: 
	7 4 1 
	8 5 2 
	9 6 3 
NOTE: Do not allocate another matrix and do the rotation. 
Input Format: 
Line-1: An integer n. 
Next N lines: n space separated integers. 
Output Format: 
Print the transformed Matrix. 
Sample Input-1: 
4 
5 1 9 11 
2 4 8 10 
13 3 6 7 
15 14 12 16 
Sample Output-1: 
15 13 2 5 
14 3 4 1 
12 6 8 9 
16 7 10 11 
1. For a NxN matrix,we need to N/2 cycles of swapping... 
2. In first cycle,Swap the elements of the first row with lastrow,and in the second cycle , 
	the 2nd  row with the 2nd last row are  to be swapped... and so on... 
3. Once the cycles are completed ,Using for loop transform the elements of  
	first row into first column,second row to second column and so on... 			 
4. Display the rotated image of the matrix. 

// REVERSE ITERATION
import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
        int matrix[][] = new int[num][num];
        for(int i=0;i<num;i++) {
            for(int j=0;j<num;j++) {
                matrix[i][j] = sc.nextInt();
            }
        }
        for(int i=0;i<num;i++) {
            for(int j=num-1;j>=0;j--) {
                System.out.print(matrix[j][i] + " ");
            }
            System.out.println();
        }
    }
}         

30th Problem
Bob given a date in string form i.e, in the following format YYYY-MM-DD,  
print the day number int that year. 
Sample Input: date = "2018-01-10" 
Output: 10 
Explanation: Given date is the 10th day of the year 2018. 
Sample Input: date = "2018-02-11" 
Output: 42 
Note: 
date from Jan 1st, 1900 to Dec 31th, 2019.

import java.util.*;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String s1 = sc.nextLine();
        LocalDate a1 = LocalDate.parse(s1);
        int date = a1.getDayOfYear();
        System.out.println(date);
    }
}                 

31st Problem
Ngit college decided to announce the toppers of 2nd year students , 
Here Management following a strategy to identify the toppers, i.e, 
They have three different set of lists with there roll numbers, 
first list is PS, second list is CS and third list is OUS.
They decided toppers of 2nd year as, the students those who are there in all three lists.
Note: lists are in sorted according to roll numbers.
Input:
1 2 3 4 5 6
2 5 7 8 9 10
1 2 4 5 8 11
Output:
2 5

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String str1 = sc.nextLine();
        String arr1[] = str1.split(" ");
        String str2 = sc.nextLine();
        String arr2[] = str2.split(" ");
        String str3 = sc.nextLine();
        String arr3[] = str3.split(" ");
        for(int i=0;i<arr1.length;i++) {
            for(int j=0;j<arr2.length;j++) {
                for(int k=0;k<arr3.length;k++) {
                    if(arr1[i].equals(arr2[j]) && arr2[j].equals(arr3[k]) && arr3[k].equals(arr1[i])) {
                        System.out.println(arr1[i]+ " ");
                    }
                }
            }
        }
    }
}       

32nd Problem 
Write a function maxsubstring (str,alpha,theta) str is the source string and have to return maximum sub string which starts with alpha and ends with theta.
input=computer                                                                                                         
m                                                                                                                      
r    	
output=                                                                                                              
Max. Substring  is:mputer  

import java.util.*;
class Test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        char alpha = sc.next().charAt(0);
        char theta = sc.next().charAt(0);
        int start = str.indexOf(alpha);
        int end = str.lastIndexOf(theta);
        if(start == -1 || end == -1 || start > end) {
            System.out.println("No substring found");
        }
        else {
        System.out.println("Max. Substring is:" + str.substring(start,end+1));
        }
    }
}

33rd Problem -> Maximum and minimum of an array using minimum number of comparisons

import java.util.*; 
class First  { 
    public static void main(String args[]) { 
        Scanner sc = new Scanner(System.in); 
        System.out.println("Enter the size: "); 
        int n = sc.nextInt(); 
        int arr[] = new int[n]; 
        int max = 0; 
        int min = 0; 
        for(int i=0;i<n;i++) { 
            arr[i] = sc.nextInt(); 
        } 
        min = arr[0]; 
        for(int i=0;i<n;i++) { 
           if(arr[i]>max) { 
            max = arr[i]; 
           } 
           if(arr[i]<=min) { 
            min = arr[i]; 
           } 
        } 
        sc.close(); 
        System.out.println("Maximum element is: "+ max); 
        System.out.println("Minimum element is: "+ min); 
    } 
} 

34th Problem 
Bob given two strings to jack, asking jack to comapre s1 and s2 to find are they following same sequence of pattern or not. if they are following print true otherwise false. 
baab 
rat mat mat rat 
Output: true 
Input:  
abba  
mat rat rat sat 
Output: false 

import java.util.HashMap; 
import java.util.*; 
class Test { 
    public static void main(String args[]) { 
        Scanner sc = new Scanner(System.in); 
        String str1 = sc.nextLine(); 
        String str2 = sc.nextLine(); 
        String str2arr[] = str2.split(" "); 
        int len = str1.length(); 
        HashMap<Character, String> map = new HashMap<>(); 
        boolean match = true; 
        for(int i=0;i<len;i++) { 
            char c = str1.charAt(i); 
            String s = str2arr[i]; 
            if(map.containsKey(c)) { 
                if(!map.get(c).equals(s)) { 
                    match = false; 
                    break; 
                } 
            } 
            else { 
                if(map.containsValue(s)) { 
                    match = false; 
                    break; 
                } 
            } 
            map.put(c,s); 
        } 
        System.out.println(match); 
    } 
}                

35th Problem 
Given a word consisting of lowercase characters from a to z, your task is to print the first character to emerge twice. 
A character a appears twice before another character b if the second occurrence 
of a is before the second occurrence of b. 
w will contain at least one character that emerge twice. 
sample1: 
Input: s = "baccadbbcz" 
Output: "c" 
Explanation: 
The character 'b' appears on the indexes 0, 6 and 7. 
The character 'a' appears on the indexes 1 and 4. 
The character 'c' appears on the indexes 2, 3 and 8. 
The character 'z' appears on the index 9. 
The character 'c' is the first character to emerge twice, 
because out of all the characters the index of its second occurrence is the smallest. 
sample 2: 
Input: s = "cbaee" 
Output: "e" 
Explanation: 
The only character that emerged twice is 'e' so we print 'e'. 
w consists of lowercase characters. 
w has at least one repeated character. 

import java.util.*; 
import java.util.HashMap; 
class Test { 
    public static void main(String args[]) {  
        Scanner sc = new Scanner(System.in); 
        String s1 = sc.nextLine(); 
        char arr[] = s1.toCharArray(); 
        HashMap<Character, Integer> al = new HashMap<>(); 
        for(int i=0;i<s1.length();i++) { 
            char c = arr[i]; 
            if(al.containsKey(c)) { 
                System.out.println(c); 
                return; 
            } 
            al.put(c,i); 
        } 
    } 
}                

36th Problem 
Given a string, find size of palindrome with maximum length. alphabets are case sensitive, for example, "bB" is not considered a palindrome here.
Example 1:
Input: s = "abccccdd"
Output: 7
Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.
Example 2:
Input: s = "a"
Output: 1
Explanation: The longest palindrome that can be built is "a", whose length is 1.
testcases:
case=1
input=abccccdd
output=7 

import java.util.*;
class test {
    public static void main(String args[]) {
       Scanner sc = new Scanner(System.in);
       String str = sc.nextLine();
       int len = 0;
       Set<Character> set = new HashSet<>();
       for(char c: str.toCharArray()) {
           if(set.contains(c)) {
               set.remove(c);
               len+=2;
           } else {
               set.add(c);
           }
       }
       if(!set.isEmpty()) {
           len++;
       }
       System.out.println(len);
    }
}                           

37th Problem -> Reversing the Arrays

import java.util.*; 
public class Solutions { 
    public static void main(String[] args) { 
        Scanner sc = new Scanner(System.in); 
        System.out.println("Enter the size of the array:\n"); 
        int len = sc.nextInt(); 
        int arr[] = new int[len]; 
        int start = 0; 
        int end = len-1; 
        for (int i=0;i<len;i++) { 
            arr[i] = sc.nextInt(); 
        } 
        while(start < end) { 
            int temp = arr[start]; 
            arr[start] = arr[end]; 
            arr[end] = temp; 
            start++; 
            end--; 
        } 
        for (int i = 0; i < len; i++) { 
            System.out.println(arr[i]); 
        } 
        sc.close(); 
    } 
}        
CONTAINS DUPLICATE ELEMENTS  IN AN ARRAY OR NOT..
class Solution { 
    public boolean containsDuplicate(int[] nums) { 
       Arrays.sort(nums); 
       for(int i=0;i<nums.length-1;i++) { 
           if(nums[i] == nums[i+1]) { 
               return true; 
           } 
       } 
       return false; 
    } 
}

38th Problem 
A string is given. identify the numbers of instances possible for the word "student"
You can use each character in the string at most once. Return the total number of instances that can be formed.
Explanation1:
input=escsceca
output=2
from the given string, the word "cse" can be formed twice
Explanation2:
input=asceasdf
output=1
Testcases:
case=1
input=escsceca
output=2 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        char[] st = s.toCharArray();
        Map<Character,Integer> mp = new HashMap<>();
        for(int i=0;i<st.length;i++) {
            if(mp.containsKey(st[i])) {
                int a = mp.get(st[i]);
                mp.put(st[i],a+1);
            }
            else {
                mp.put(st[i],1);
            }
        }
        int out=0;
        int min=0;
        for(Map.Entry<Character,Integer> me:mp.entrySet()) {
            char d = me.getKey();
            if(d=='c' || d=='s' || d=='e') {
                out = me.getValue();
                if(out<min) {
                    out = min;
                }
            }
        }
        System.out.print(out);
    }
}

39th Problem 
You are given list of numbers. find the sum of numbers that appear exactly once in the list.
Example 1:
Input: nums = [1,2,3,2]
Output: 4
Explanation: The non repeating numbers are [1,3], and the sum is 4.
Example 2:
Input: nums = [1,1,1,1,1]
Output: 0
Explanation: There are no non-repeating numbers, and the sum is 0.
Example 3:
Input: nums = [1,2,3,4,5]
Output: 15
Explanation: The non repeating numbers are [1,2,3,4,5], and the sum is 15.
Testcases:
case=1
input=1 2 3 2
output=4

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String[] sa = s.split(" ");
        Map<String,Integer> mp = new HashMap<>();
        for(int i=0;i<sa.length;i++) {
            if(mp.containsKey(sa[i])) {
                int a = mp.get(sa[i]);
                mp.put(sa[i],a+1);
            }
            else {
                mp.put(sa[i],1);
            }
        }
        int sum = 0;
        for(Map.Entry<String, Integer> me:mp.entrySet()) {
            if(me.getValue() == 1) {
                int d = Integer.parseInt(me.getKey());
                sum = sum+d;
            }
        }
        System.out.println(sum);
    }
}      

40th Problem 
You are given the array of routes, where route[i] = [stateAi, stateBi] means there exists a direct path 
going from stateAi to stateBi. Return the destination state, that is, the state without any route outgoing 
to another state.
It is guaranteed that the graph of routes forms a line without any loop, therefore, 
there will be exactly one destination city.
Example 1:
Input: routes = [["telangana","andhrapradesh"],["andhrapradesh","tamilnadu"],["tamilnadu","kerala"]]
Output: "kerala" 
Explanation: Starting at "telangana" state you will reach "kerala" state which is the destination city. 
Your trip consist of: "telangana" -> "andhrapradesh" -> "tamilnadu" -> "kerala".
Example 2:
Input: routes = [["ladakh","jammu"],["punjab","delhi"],["jammu","punjab"]]
Output: "delhi"
Explanation: All possible trips are: 
"ladakh" -> "jammu" -> "punjab" -> "delhi". 
"jammu" -> "punjab" -> "delhi"
"punjab" -> "delhi"
"delhi"
Clearly the destination state is "A".
Example 3:
Input: routes = [["telangana","maharashtra"]]
Output: "maharashtra"
testcases:
case=1
input=telangana,andhrapradesh,andhrapradesh,tamilnadu,tamilnadu,kerala
output=kerala 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String input = sc.nextLine();
        String[] routes = input.split(",");
        ArrayList<String> destinations = new ArrayList<String>();
        for(int i=1;i<routes.length;i+=2) {
            destinations.add(routes[i]);
        }
        for(int i=0;i<routes.length;i+=2) {
            destinations.remove(routes[i]);
        }
        String destinationState = destinations.get(0);
        System.out.println(destinationState);
    }
}               

41st Problem 
There are n Circles and each Circle is either pink, Yellow, or White. The Circles are distributed across ten poles labeled from 0 to 9. 
You are given a string Circles of length 2n that describes the n Circles that are placed onto the poles. Every two characters in Circles forms a color-position pair that is used to describe each Circle where: 
The first character of the ith pair denotes the ith Circles color ('P', 'Y', 'W'). 
The second character of the ith pair denotes the pole that the ith Circle is placed on ('0' to '9'). 
For example, "P3Y2W1" describes n == 3 Circles : a pink Circle placed onto the pole labeled 3, a Yellow Circle placed onto the pole labeled 2, and a White Circle placed onto the pole labeled 1. 
Return the number of poles that have all three colors of Circles on them. 
Example: 
Input: input = "W0W6Y0P6P0P6Y9" 
Output: 1 
Explanation:  
- The pole labeled 0 holds 3 Circles with all colors: pink, yellow, and white. 
- The pole labeled 6 holds 3 Circles , but it only has pink and white. 
- The pole labeled 9 holds only a yellow Circle. 
Thus, the number of poles with all three colors is 1. 

import java.util.*; 
class Test { 
    public static void main(String args[]) { 
        Scanner sc = new Scanner(System.in); 
        String str = sc.nextLine(); 
        int count = 0; 
        HashSet<Character> hs = new HashSet<>(); 
        for(int i=0;i<=9;i++) { 
            for(int j=0;j<str.length();j++) { 
                if((str.charAt(j)-48)==i) 
                    hs.add(str.charAt(j-1)); 
            } 
                if(hs.size()==3) 
                count++; 
                hs.clear(); 
        } 
        System.out.println(count); 
    } 
}        

42nd Problem 
Given set of nodes like [2,1,1,2] , using them form a singly linked list,  
left node in the linked list represents MSB and right node  in the linked list represents LSB, 
where 2 is MSB and 2 is LSB. 
by using above nodes you can form singly linked list like 2-->1-->1-->2. 
your task is to print yes if it is palindrome otherwise print no. 
Examples: 
input=2,1,1,2 
output=yes 
input=2,1 
output=no 

import java.util.*; 
class Test { 
    public static void main(String args[]) { 
        Scanner sc = new Scanner(System.in); 
        String s = sc.nextLine(); 
        String str[] = s.split(","); 
        LinkedList <Integer> ll = new LinkedList<Integer>(); 
        for(int i=0;i<str.length;i++) { 
            ll.add(Integer.parseInt(str[i])); 
        } 
        LinkedList<Integer> ll1 = new LinkedList<Integer>(); 
        for(int i=str.length-1;i>=0;i--) { 
            ll1.add(Integer.parseInt(str[i])); 
        } 
        if(ll.equals(ll1)) { 
            System.out.println("yes"); 
        } 
        else { 
            System.out.println("no"); 
        }   
    } 
}           

43rd Problem
You are given an array of numbers. the following can be done in single iteration:
1. select two equal numbers.
2. delete both of them from the array.
3. repeat steps 1 & 2 until there is no equal numbers available in the array.
return the number of pairs deleted and leftover elements in the array
Example 1:
Input: [1,3,2,1,3,2,2]
Output: [3,1]
Explanation:
first 1,1 will be selected and deleted, resulting array = [3,2,3,2,2].
then 3,3 will be selected and deleted, resulting array= [2,2,2].
then 2,2 will be selected and deleted, resulting array= [2].
No more pairs can be formed. A total of 3 pairs deleted, and there is 1 number leftover in nums.
Example 2:
Input: [1,1]
Output:[1,0]
Explanation: first 1,1 will be selected and deleted, resulting array= [].
No more pairs can be formed. A total of 1 pair deleted, and there are 0 numbers leftover in the array.
Example 3:
Input: [0]
Output: [0,1]
Explanation: No pairs can be formed, and there is 1 number leftover in the array.
Testcases:
case=1
input=1,3,2,1,3,2,2
output=3,1 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String[] arr = sc.nextLine().split(",");
        int n = arr.length;
        int[] nums = new int[n];
        for(int i=0;i<n;i++) {
            nums[i] = Integer.parseInt(arr[i]);
        }
        int count=0;
        for(int i=0;i<n;i++) {
            if(nums[i] == -1) {
                continue;
            }
            for(int j=i+1;j<n;j++) {
                if(nums[j] == -1) {
                    continue;
                }
                if(nums[i] == nums[j]) {
                    nums[i] = -1;
                    nums[j] = -1;
                    count++;
                    break;
                }
            }
        }
        int c1=0;
        for(int i=0;i<n;i++) {
            if(nums[i] != -1) {
                c1++;
            }
        }
        System.out.println(count+","+c1);
    }
}

44th Problem (Max element of an array)
import java.util.*;
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("enter the size of the array: ");
        int size = sc.nextInt();
        System.out.println("enter the elements");
        int arr[] = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = sc.nextInt();
        }
        Arrays.sort(arr);
        System.out.println(arr[arr.length - 1]);
        sc.close();
    }
}               
For 2nd largest element in the array, you just need to sort the array and use this ->  System.out.println(arr[arr.length - 2]); 
             
45th Problem (checking if array is sorted or not) 
import java.util.*;
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the size of the array: ");
        int size = sc.nextInt();
        System.out.println("Enter the elements:");
        int arr[] = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = sc.nextInt();
        }
        boolean isSorted = true;
        for (int i = 1; i < size; i++) {
            if (arr[i] < arr[i - 1]) {
                isSorted = false;
                break;
            }
        }
        if (isSorted) {
            System.out.println("The array is sorted.");
        } else {
            System.out.println("The array is not sorted.");
        }
        sc.close();
    }
}
other solution (Leetcode)
 class Solution {
    public boolean check(int[] nums) {
        int n = nums.length;
        int pivot = 0;
        // Find the pivot point
        for (int i = 1; i < n; i++) {
            if (nums[i] < nums[i - 1]) {
                pivot = i;
                break;
            }
        }
        // Check if the elements after the pivot are in non-decreasing order
        for (int i = pivot + 1; i < n; i++) {
            if (nums[i] < nums[i - 1]) {
                return false;
            }
        }
        // Check if the elements before the pivot (if any) are in non-decreasing order
        if (pivot > 0 && nums[n - 1] > nums[0]) {
            return false;
        }
        return true;
    }
}

46th Problem (linear search)
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the size of the array: ");
        int size = sc.nextInt();
        System.out.println("Enter the elements:");
        int arr[] = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = sc.nextInt();
        }
        System.out.println("enter the target:");
       int target = sc.nextInt();
       for (int i = 0; i < size; i++) {
        if(arr[i] == target){
            System.out.println(i);
        }
       }
        sc.close();
    }
}

47th problem (removing the duplicate elements from the array)
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        int uniqueCount = 1;
        int i = 1; 
        int j = 1;
        while (i < n) {
            if (nums[i] != nums[i - 1]) {
                nums[j] = nums[i];
                uniqueCount++;
                j++;
            }
            i++;
        }
        return uniqueCount;
    }
}                                     

48th Problem (Collections)
Array List
import java.util.*;
class Test {
    public static void main(String args[]) {
        ArrayList<Integer> cs = new ArrayList<Integer>();
        cs.add(1);
        cs.add(2);
        cs.add(3);
        cs.add(4);
        cs.add(5);
        System.out.println("Get"+cs.get(1));     
        cs.remove(2);   
        Iterator<Integer> it = cs.iterator();
        while(it.hasNext()) {
            System.out.println(it.next());
        }
        ArrayList<String> cs1 = new ArrayList<String>();
        cs1.add("xyz");
        cs1.add("abc");
        cs1.add("def");
    }
}                              

LinkedList
import java.util.*;
class Test {
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        LinkedList<Integer> ll=new LinkedList<Integer>();
        for(int i=0;i<n;i++) {
            ll.add(sc.nextInt());
        }
        for(int i=0;i<n;i++) {
            System.out.print(ll.get(i)+" ");
        }
        System.out.println();
        System.out.println(ll.size());
        System.out.println(ll.contains(2));
        System.out.println(ll.remove(1));
        System.out.println(ll.indexOf(1));
        ll.set(0,6);
        Iterator<Integer> it=ll.iterator();
        while(it.hasNext()) {
            System.out.print(it.next()+" ");
        }
    }
}     

TreeMap
import java.util.*;
class Test {
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        TreeMap<Integer,String> t=new TreeMap<Integer,String>();
        for(int i=0;i<n;i++) {
            t.put(sc.nextInt(),sc.nextLine());
        }
        System.out.println(t.containsKey(1));
        System.out.println(t.containsValue("A"));
        System.out.println(t.get(2));
        System.out.println(t.remove(3));
        System.out.println(t.size());
        System.out.println(t.values()+" ");
        for(Map.Entry<Integer,String> me:t.entrySet()) {
            System.out.println(me.getKey()+"-"+me.getValue());
        }
    }
}     

HashMap
import java.util.*;
class Test {
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int size=sc.nextInt();
        TreeMap<Integer,String> t=new TreeMap<Integer,String>();
        for(int i=0;i<size;i++) {
            t.put(sc.nextInt(),sc.nextLine());
        }
        System.out.println(t.containsKey(1));
        System.out.println(t.containsValue("A"));
        System.out.println(t.get(2));
        System.out.println(t.remove(3));
        System.out.println(t.size());
        System.out.println(t.values()+" ");
        for(Map.Entry<Integer,String> me:t.entrySet()) {
            System.out.println(me.getKey()+"-"+me.getValue());
        }
        
    }
}     

Legacy Vector
import java.util.*;
class Test {
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int size=sc.nextInt();
        Vector<Integer> v=new Vector<Integer>();
        for(int i=0;i<size;i++) {
            v.add(sc.nextInt());
        }
        System.out.println(v.size());
        System.out.println(v.contains(1));
        System.out.println(v.elementAt(2));
        System.out.println(v.firstElement());
        System.out.println(v.get(4));
        System.out.println(v.indexOf(3));
        System.out.println(v.remove(1));
        System.out.println(v.set(1,2));
        Iterator<Integer> it=v.iterator();
        while(it.hasNext()) {
            System.out.print(it.next()+" ");
        }
    }
}     

Legacy HashTable
import java.util.*;
class Test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int size = sc.nextInt();
        Hashtable<Integer, Integer> ht = new Hashtable<>();
        for (int i = 0; i < size; i++) {
            int key = sc.nextInt();
            int value = sc.nextInt();
            ht.put(key, value);
        }
        System.out.println(ht.size());
        System.out.println(ht.containsKey(1));
        System.out.println(ht.get(2));
        System.out.println(ht.keySet().iterator().next());
        System.out.println(ht.get(4));
        System.out.println(ht.containsValue(3));
        System.out.println(ht.remove(1));
        ht.put(1, 2);
        Enumeration<Integer> keys = ht.keys();
        while (keys.hasMoreElements()) {
            int key = keys.nextElement();
            System.out.print(ht.get(key) + " ");
        }
    }
}

Legacy Dictionary
import java.util.*;
class Test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int size = sc.nextInt();
        Hashtable<Integer, Integer> dictionary = new Hashtable<>();
        for (int i = 0; i < size; i++) {
            int key = sc.nextInt();
            int value = sc.nextInt();
            dictionary.put(key, value);
        }
        System.out.println(dictionary.size());
        System.out.println(dictionary.containsKey(1));
        System.out.println(dictionary.get(2));
        System.out.println(dictionary.get(0));
        System.out.println(dictionary.get(4));
        System.out.println(dictionary.containsValue(3));
        System.out.println(dictionary.remove(1));
        dictionary.put(1, 2);
        Enumeration<Integer> keys = dictionary.keys();
        while (keys.hasMoreElements()) {
            int key = keys.nextElement();
            System.out.print(dictionary.get(key) + " ");
        }
    }
}  

Iterator
import java.util.*;
class Test {
    public static void main(String[] args) {
        ArrayList<String> a = new ArrayList<String>();
        a.add("ab");
        a.add("bc");
        a.add("cd");
        a.add("de");
        Iterator<String> it = a.iterator();
        while (it.hasNext()) {
            System.out.print(it.next() + " ");
        }
    }
}

List Iterator
import java.util.*;
class Test {
    public static void main(String[] args) {
        ArrayList<String> a = new ArrayList<String>();
        a.add("ab");
        a.add("bc");
        a.add("cd");
        a.add("de");
        ListIterator<String> litr = a.listIterator();
        while (litr.hasNext()) {
            System.out.print(litr.next() + " ");
        }
        while (litr.hasPrevious()) {
            System.out.print(litr.previous() + " ");
        }
    }
}

49th Problem 
write a function that given an array of N integers, shall return the biggest value X, which occurs in A exactly X times.
exp-> A=[3,1,4,1,5] shall return 0. no value in the array meeting the function.
exp -> A=[5,5,5,5,5] shall return 5.
exp-> A=[3,8,2,3,3,2] shall return 3. the value 2 occurs 2 times and the value 3 occurs 3 times. they meet the conditions. the value 8 occurs only once.
so, it doesn't meet the conditions. the max of 2 and 3 is 3. so, return 3.

import java.util.*;
public class opentextone {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String [] sa = s.split(" ");
        int arr [] = new int [sa.length];
        for(int i=0;i<arr.length;i++) {
            arr[i]=Integer.valueOf(sa[i]);
        }
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<arr.length;i++) {
            if(map.get(arr[i])!=null)//map.containsKey() {
                map.put(arr[i],map.get(arr[i])+1);
            }
            else {
                map.put(arr[i],1);
            }
        }
         System.out.println(map);
        int max =0;
        for(HashMap.Entry<Integer,Integer> entry  : map.entrySet()) {
            int k = entry.getKey();
            int v = entry.getValue();
            if(k==v && v>1 ) {
                if(k>max) {
                    max=k;
                }
            }
        }
        System.out.println(max);
    }
}

50th Problem 
You are given an array of integers. you have to create pairs of them such that every pair consist of equal numbers. each array element may belong to one pair only.
write a function that given an array returns whether it splits all integers into pairs.
exp-> A=[1,2,2,1], your function should return true, as the pairs are (A[0],A[3]) i.e 1 and (A[1],A[2]) i.e 2
exp -> A=[7,7,7], your function shall return false, as only 1 pair is formed and the other one is left out.

import java.util.*;
public class opentexttwo {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String sa [] = s.split(" ");
        int arr [] = new int [sa.length];
        for(int i=0;i<sa.length;i++) {
            arr[i]=Integer.valueOf(sa[i]);
        }
        System.out.println(task(arr));
    }
    public static boolean task(int arr[]) {
        if(arr.length%2!=0) {
            return false;
        }
        int n= arr.length-1;
        for(int i=0;i<arr.length/2;i++,n--) {
            if(arr[i]!=arr[n]) {
                return false;
            }
        }
        return true;
    }
}                  

51st Problem
write a function solution that, given integer N, returns the smallest non-negative integer whose individual digits sum to N.
exp-> n = 16, the function should return 79. there are many numbers whose sum is 16 but the smallest such number must be 79.
exp-> n = 19, function should return 199. many numbers sum can be 19 but the smallest such number is 199.

import java.util.*;
public class opentextthree {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.println(task(n));
    }
    public static int task(int n) {
        if(n<10) {
            return n;
        }
        String s="";
        while(n>9) {
            n=n-9; 
            s=s+'9';
        }
        s=s+Integer.toString(n);
        String rs="";
        for(int i=s.length()-1;i>=0;i--) {
            rs=rs+s.charAt(i);
        }
        return Integer.valueOf(rs);
    }
}

52nd Problem
Write a function that given an integer N, returns the smallest integer greater than N, the sum of whose digits is twice as big as the sum of digits of N.
exp-> N = 14, function should return 19. the sum of digits of 19(1+9=10) is twice as big as the sum of 14(1+4=5).
exp-> N = 10, function should return 11. the sum of digits of 11(1+1=2) is twice as big as the sum of 10(1+0=1). 

import java.util.*;
public class opentextfour {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.println(task(n));
    }
    public static int task(int n) {
        int sum=0;
        while(n!=0) {
            sum =sum + n%10;
            n=n/10;
        }
        int x = 2*sum;
        String s ="";
        if(x<10) {
            x=x-1;
            s='1'+Integer.toString(x);
        }
        else {
            while(x>9) {
                x=x-9;
                s=s+'9';
            }
            s=s+Integer.toString(x);
            String rs="";
            for(int i=s.length()-1;i>=0;i--) {
                rs=rs+s.charAt(i);
            }
            s=rs;
        }
        return Integer.valueOf(s);
    }
}                         

53rd Problem (String reverse) 
import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {        
        Scanner sc=new Scanner(System.in);
        String A=sc.next();
        int len = A.length();
        boolean isPalindrome = true;
        for(int i=0;i<len/2;i++) {
            if(A.charAt(i) != A.charAt(len-i-1)) {
                isPalindrome = false;
                break;
            } 
        }
        if(isPalindrome) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }
        sc.close();
    }
}

54th Problem (Datatypes and range)
import java.util.*;
import java.io.*;
class Solution {
    public static void main(String []args) {
        Scanner sc = new Scanner(System.in);
        int t=sc.nextInt();
        for(int i=0;i<t;i++) {
            try {
                long x=sc.nextLong();
                System.out.println(x+" can be fitted in:");
                if(x>=-128 && x<=127) {
                    System.out.println("* byte");
                }
                if(x>=-32768 && x<=32767) {
                    System.out.println("* short");
                }
                if(x>=-2147483648 && x<=2147483647) {
                    System.out.println("* int");
                }
                if(x>=-9223372036854775808L && x<=9223372036854775807L) {
                    System.out.println("* long");
                }
            }
            catch(Exception e) {
                System.out.println(sc.next()+" can't be fitted anywhere.");
            }
        }
    }
}                            

55th Problem
Given two strings of lowercase English letters,  and , perform the following operations:
Sum the lengths of A and B. Determine if  is lexicographically larger than  (i.e.: does  come before  in the dictionary?).
Capitalize the first letter in  and  and print them on a single line, separated by a space.                  
   
import java.util.*;
class test {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        String A=sc.next();
        String B=sc.next();
        A = A.substring(0, 1).toUpperCase() + A.substring(1);
        B = B.substring(0, 1).toUpperCase() + B.substring(1);
        int len1 = A.length();
        int len2 = B.length();
        System.out.println(len1+len2);
        int result = A.compareTo(B);
        if(result < 0) {
            System.out.println("No");
        } else {
            System.out.println("Yes");
        }
        System.out.print(A+" "+B);
    }
}                 

56th Problem
Arun wants to design a Right Angle Star Pattern. Let’s help him by accepting a number.
3
*
* *
* * *

import java.util.*;
class RightTrianglePattern {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int size = sc.nextInt();
        for(int i=0;i<size;i++) {
            for(int j=0;j<=i;j++) {
                System.out.print("* ");
            }
                System.out.println();
        }
    }
}

57th Problem
Varun wants to design a LeftTrianglePattern. Let’s help him by accepting a number.
5
           *
         * *
       * * *
     * * * *
   * * * * *

import java.util.*;
class LeftTrianglePattern {
    public static void main(String args[]) {
         Scanner sc = new Scanner(System.in);
        int size = sc.nextInt();
        for(int i=0;i<size;i++) {
            for(int j=5;j>i;j--) {
                System.out.print(" ");
            }
            for(int j=0;j<i;j++) {
                System.out.print("*");
            }
            System.out.println();
        }
    }
}

58th Problem
Online Shopping Cart: You are developing an online shopping cart system. Identify the classes, objects, and behaviors involved.
Scenario: Users can add items to their shopping cart,remove items, and proceed to checkout. Each item has properties like name, price, and quantity. 
The system should calculate the total cost of the items in the cart and apply any applicable discounts or promotions.
input and output:
Enter your choice: 1
Enter item name: icecream
Enter item price: 2
Enter item quantity: 2
Item added to the cart.
1. Add item
2. Remove item
3. Checkout
4. Exit
Enter your choice: 3
Total cost: $4.0
Thank you for shopping with us!

import java.util.*;
class ShoppingCart {
    private List<Item> items;
    public ShoppingCart() {
        items = new ArrayList<>();
    }
    public void addItem(String name, double price, int quantity) {
        Item item = new Item(name, price, quantity);
        items.add(item);
        System.out.println("Item added to the cart.");
    }
    public void removeItem(String name) {
        for (Item item : items) {
            if (item.getName().equalsIgnoreCase(name)) {
                items.remove(item);
                System.out.println("Item removed from the cart.");
                return;
            }
        }
        System.out.println("Item not found in the cart.");
    }
    public double calculateTotalCost() {
        double totalCost = 0.0;
        for (Item item : items) {
            totalCost += item.getPrice() * item.getQuantity();
        }
        return totalCost;
    }
    public void checkout() {
        double totalCost = calculateTotalCost();
        System.out.println("Total cost: $" + totalCost);
        System.out.println("Thank you for shopping with us!");
    }
}
class Item {
    private String name;
    private double price;
    private int quantity;

    public Item(String name, double price, int quantity) {
        this.name = name;
        this.price = price;
        this.quantity = quantity;
    }
    public String getName() {
        return name;
    }
    public double getPrice() {
        return price;
    }
    public int getQuantity() {
        return quantity;
    }
}
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        ShoppingCart cart = new ShoppingCart();
        while (true) {
            System.out.println("1. Add item");
            System.out.println("2. Remove item");
            System.out.println("3. Checkout");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");
            int choice = sc.nextInt();
            switch (choice) {
                case 1:
                    System.out.print("Enter item name: ");
                    String name = sc.next();
                    System.out.print("Enter item price: ");
                    double price = sc.nextDouble();
                    System.out.print("Enter item quantity: ");
                    int quantity = sc.nextInt();
                    cart.addItem(name, price, quantity);
                    break;
                case 2:
                    System.out.print("Enter item name to remove: ");
                    String itemName = sc.next();
                    cart.removeItem(itemName);
                    break;
                case 3:
                    cart.checkout();
                    System.exit(0);
                case 4:
                    System.exit(0);
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }
}

59th Problem
Banking System: You are building a banking system. Identify the classes, objects, and behaviors involved.
Scenario: Customers can open bank accounts, deposit money,withdraw money, and check their account balance. 
Each account has a unique account number, owner name, and 
balance. The system should handle transactions accurately and update account balances accordingly.
1. Open an account
2. Deposit money
3. Withdraw money
4. Check account balance
0. Exit
Enter your choice:
1
Enter account number: 12345
Enter account owner name: Santosh
Account opened successfully.
1. Open an account
2. Deposit money
3. Withdraw money
4. Check account balance
0. Exit
Enter your choice: 2
Enter account number: 12345
Enter the amount to deposit: 23450
Amount deposited successfully.
1. Open an account
2. Deposit money
3. Withdraw money
4. Check account balance
0. Exit
Enter your choice: 4
Enter account number: 12345
Account balance: 23450.0
1. Open an account
2. Deposit money
3. Withdraw money
4. Check account balance
0. Exit
Enter your choice: 0
Exiting..

import java.util.*;
class BankAcc {
    double Accno;
    String name;
    double balance;
    BankAcc(double Accno, String name, double balance) {
        this.Accno = Accno;
        this.name = name;
        this.balance = balance;
    }
    void deposit(double amt) {
        balance = balance + amt;
        System.out.print("Amount deposited successfully.");
    }
    void withdraw(double amt) {
        if (amt > balance) {
            System.out.print("No Balance");
        } else {
            balance = balance - amt;
            System.out.print("Amount withdrawn successfully.");
        }
    }
    double getBalance() {
        return balance;
    }
}
class BankSystem {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        BankAcc account = null;
        while (true) {
            System.out.println("1. Open an account");
            System.out.println("2. Deposit money");
            System.out.println("3. Withdraw money");
            System.out.println("4. Check account balance");
            System.out.println("0. Exit");
            System.out.print("Enter your choice: ");
            int choice = sc.nextInt();
            switch (choice) {
                case 1:
                    System.out.print("Enter account number: ");
                    double accNo = sc.nextDouble();
                    sc.nextLine();
                    System.out.print("Enter account owner name: ");
                    String name = sc.nextLine();
                    System.out.print("Enter initial balance: ");
                    double initialBalance = sc.nextDouble();
                    account = new BankAcc(accNo, name, initialBalance);
                    System.out.println("Account opened successfully.");
                    break;
                case 2:
                    if (account != null) {
                        System.out.print("Enter the amount to deposit: ");
                        double depositAmt = sc.nextDouble();
                        account.deposit(depositAmt);
                    } else {
                        System.out.println("No account opened. Please open an account first.");
                    }
                    break;
                case 3:
                    if (account != null) {
                        System.out.print("Enter the amount to withdraw: ");
                        double withdrawAmt = sc.nextDouble();
                        account.withdraw(withdrawAmt);
                    } else {
                        System.out.println("No account opened. Please open an account first.");
                    }
                    break;
                case 4:
                    if (account != null) {
                        System.out.println("Account balance: " + account.getBalance());
                    } else {
                        System.out.println("No account opened. Please open an account first.");
                    }
                    break;
                case 0:
                    System.out.println("Exiting..");
                    System.exit(0);
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }
}

60th Problem
Ravi wants to insert an element into given list of numbers for a given position . 
Enter the size of the array: 5
Enter the elements of the array:
1
2
3
4
5
Enter the element to insert: 7
Enter the index to insert the element at: 1
Modified array: [1, 7, 2, 3, 4, 5] 

import java.util.*;
class Array1 {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the size of the array: ");
        int n = sc.nextInt();
        System.out.println("Enter the elements of the array: ");
        int arr[] = new int[n+1];
        for(int i=0;i<n;i++) {
            arr[i] = sc.nextInt();
        }
        System.out.println("Enter the element to insert: ");
        int ele = sc.nextInt();
        System.out.println("Enter the index to insert the element at: ");
        int ind = sc.nextInt();
        for(int i=n;i>ind;i--) {
            arr[i] = arr[i-1];
        }
        arr[ind] = ele;
        System.out.print("Modified array: ");
        System.out.print(Arrays.toString(arr));
    }
}

61st Problem
Write a java Program to remove an element in a given position in an array.
Enter the size of the array: 5
Enter the elements of the array:
1
2
3
4
5
Enter the position of the element to be removed: 1
Array after removing the element:
1 3 4 5
Enter the size of the array: 8
Enter the elements of the array:
200
123
34
3
22
1
4
6
Enter the position of the element to be removed: 0
Array after removing the element:
123 34 3 22 1 4 6 

import java.util.*;
class Remove {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the size of the array: ");
        int size = sc.nextInt();
        System.out.print("Enter the elements of the array: ");
        int arr[] = new int[size];
        for(int i=0;i<size;i++) {
            arr[i] = sc.nextInt();
        }
        System.out.print("Enter the position of the element to be removed: ");
        int pos = sc.nextInt();
        for(int i=pos;i<size-1;i++) {
            arr[i]=arr[i+1];
        }
        System.out.println("Array after removing the element: ");
        for(int i=0;i<size-1;i++) {
            System.out.print(arr[i]+ " ");
        }
    }
}

62nd Problem
find the sum of elements available at the square position of given 
indices in the array 
Enter the size of the array: 5                                                                                          
Enter the elements of the array:                                                                                        
1 2 3 4 5                                                                                                               
Enter the indices: 0 1                                                                                                      
sum is:3  
Enter the size of the array: 5                                                                                          
Enter the elements of the array:                                                                                        
1 2 3 4 5                                                                                                               
Enter the indices: 1 2                                                                                                      
sum is: 5 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the size of the array: ");
        int size = sc.nextInt();
        System.out.print("Enter the elements of the array: ");
        int arr[] = new int[size];
        for(int i=0;i<size;i++) {
            arr[i] = sc.nextInt();
        }
        System.out.print("Enter the indices: ");
        int i1 = sc.nextInt();
        int i2 = sc.nextInt();
        System.out.print("sum is: ");
        int i3 = arr[i1]+arr[i2];
        System.out.print(i3);
    }
}

63rd Problem
Rithika wants to find 3rd largest element from a given group of numbers. lets help her by writing a java program
1.Enter the size of the array: 5
Enter the array elements:
1
2
3
4
5
The third largest element is: 3
2.Enter the size of the array: 5
Enter the array elements:
9
3
1
6
2
The third largest element is: 3 

import java.util.*;
class Test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the size of the array: ");
        int size = sc.nextInt();
        System.out.println("Enter the array elements: ");
        int arr[] = new int[size];
        for(int i=0;i<size;i++) {
            arr[i] = sc.nextInt();
        }
        int a,b,c=0;
        for(int i=0;i<size;i++) {
            if(arr[i]>a) {
                c=b;
                b=a;
                a=arr[i];
            }
            else if(arr[i]>b) {
                c=b;
                b=arr[i];
            }
            else if(arr[i]>c) {
                c=arr[i];
            }
        }
        System.out.println("The third largest element is: "+c);
    }
}

64th Problem
Write a Java program that takes an input array, finds a number
in the array which is a multiple of three, squares its index, 
and displays the result. 
The program takes the input array and index from the user
Enter the size of the array: 5
Enter the array elements:
3 6 9 12 15
Enter the index: 4
The number at index 4 (which is a multiple of 3) is 12, and its index squared is 16.
Enter the size of the array: 3
Enter the array elements:8 9 2
Enter the index: 3
No number found at index 3 that is a multiple of 3.

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the size of the array: ");
        int size = sc.nextInt();
        System.out.print("Enter the array elements: ");
        int arr[] = new int[size];
        for(int i=0;i<size;i++) {
            arr[i] = sc.nextInt();
        }
        System.out.print("Enter the index: ");
        int ind = sc.nextInt();
        if(arr[ind - 1]%3 == 0) {
            System.out.print("The number at index "+ ind +" (which is a multiple of 3) is "+ ind*3 +" ,and its index squared is "+ind*ind+" ");
        }
        else {
            System.out.printf("No number found at index "+ ind +" that is a multiple of 3");
        }
    }
}

65th Problem
Write a Java program to calculate Sum and Average values of an array.
Enter the number of elements in the array: 4
Enter the elements of the array:
23
45
67
89
Sum: 224
Average: 56.0
Enter the number of elements in the array: 5
Enter the elements of the array:
1 2 3 4 5
Sum: 15
Average: 3.0 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the number of elements in the array: ");
        int sum = 0;
        int num = sc.nextInt();
        System.out.print("Enter the elements of the array: ");
        int arr[] = new int[num];
        for(int i=0;i<num;i++) {
            arr[i] = sc.nextInt();
            sum = sum + arr[i];
        }
        System.out.println("Sum: " + sum);
        float avg = sum/num;
        System.out.print("Average: " + avg);
    }
}

66th Problem
Write a Java program to reverse an array of integer values.
Enter the size of the array: 4
Enter the elements of the array:
Element 1: 34
Element 2: 56
Element 3: 78
Element 4: 90
Reversed array:
90 78 56 34

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the size of the array: ");
        int size = sc.nextInt();
        System.out.print("Enter the elements of the array: ");
        int arr[] = new int[size];
        for(int i=0;i<size;i++)
        {
            System.out.println("Element "+(i+1)+": ");
            arr[i] = sc.nextInt();
        }
        System.out.print("Reversed array: ");
        for(int i = size-1; i>=0; i--)
        {
            System.out.print(arr[i]+" ");
        }
    }
}

67th Problem
Write a Java program to input an array Of N elements and display all even index elements
Enter the size of the array: 3
Enter the elements of the array:
Element at index 0: -2
Element at index 1: 56
Element at index 2: 78
Elements at even indices:
Element at index 0: -2
Element at index 2: 78 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the size of the array: ");
        int size = sc.nextInt();
        System.out.println("Enter the elements of the array: ");
        int arr[] = new int[size];
        for(int i=0;i<size;i++) {
            System.out.print("Element at index "+i+": ");
            arr[i] = sc.nextInt();
        }
        System.out.println("Elements at even indices: ");
        for(int i=0;i<size;i++) {
            if(i%2==0) {
                System.out.println("Element at index "+(i)+": " + arr[i]);
            }
        }
    }
}

68th Problem
sum of elements present at even and odd indices
Enter the number of elements in the array: 5
Enter the elements of the array:
2 3 4 5 6
Sum of elements at even indices: 12
Sum of elements at odd indices: 8

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the number of elements in the array: ");
        int size = sc.nextInt();
        System.out.print("Enter the elements of the array: ");
        int arr[] = new int[size];
        int sum1 = 0,sum2 = 0;
        for(int i=0;i<size;i++) {
            arr[i] = sc.nextInt();
            if(i%2 == 0) {
                sum1 = sum1+arr[i];
            }
            else {
                sum2 = sum2+arr[i];
            }
        }
        System.out.println("Sum of elements at even indices: "+ sum1);
        System.out.println("Sum of elements at odd indices: "+ sum2);
    }
}

69th Problem
Write a Java program to test if an array contains a specific value.
Enter the size of the array: 4
Enter the elements of the array:
Element 0: 1
Element 1: 2
Element 2: 3
Element 3: 4
Enter the value to search for: 1
The array contains the value 1 at index 0.
Enter the size of the array: 3
Enter the elements of the array:
Element 0: 23
Element 1: 45
Element 2: 89
Enter the value to search for: 9
The array does not contain the value 9.

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the size of the array: ");
        int size = sc.nextInt();
        int arr[] = new int[size];
        int flag = -1;
        System.out.println("Enter the elements of the array: ");
        for(int i=0;i<size;i++) {
            System.out.print("Element "+i+": ");
            arr[i] = sc.nextInt();
        }
        System.out.print("Enter the value to search for: ");
        int search = sc.nextInt();
        for(int i=0;i<size;i++) {
            if(arr[i] == search) {
                flag = i;
                break;
            }
            else {
                flag = -1;
            }
        }
        if(flag != -1) {
        System.out.print("The array contains the value "+search+" at index "+flag+".");
           }
        else {
      System.out.print("The array does not contain the value "+search+""); 
        }
  }
}

70th Problem
Write a Program to input N integers in an array,print the greatest and smallest integers from the array
Enter Size of Array:3                                                                                                                                                                                                             
Enter the elements:10 20 30                                                                                                                                                                                                                   
Maximum Number: 30                                                                                                                                                                                                                          
Minimum Number: 10    

 import java.util.*;
 class test {
     public static void main(String args[]) {
         Scanner sc = new Scanner(System.in);
         System.out.print("Enter Size of Array: ");
         int size = sc.nextInt();
         int max = 0;
         int min = 0;
         System.out.print("Enter the elements: ");
         int arr[] = new int[size];
         for(int i=0;i<size;i++) {
             arr[i] = sc.nextInt();
         }
         min = arr[0];
         for(int i=0;i<size;i++) {
             if(arr[i]>max) {
                 max = arr[i];
             }
             if(arr[i]<min) {
                 min = arr[i];
             }
         }
        //  Arrays.sort(arr);
         System.out.println("Maximum Number: "+max);
         System.out.print("Minimum Number: "+ min);
     }
 }

71st Problem
Write a program to input N elements in an array. Print the count of single digit and double digit numbers.
Enter the number of elements in the array: 3                                                                            
Enter element 1: 10                                                                                                    
Enter element 2: 11                                                                                                    
Enter element 3: 100                                                                                                    
Count of single-digit numbers: 0                                                                                        
Count of double-digit numbers: 2 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the number of elements in the array: ");
        int n = sc.nextInt();
        int arr[] = new int[n];
        int s_d_c = 0;
        int d_d_c = 0;
        for(int i=0;i<n;i++) {
            System.out.print("Enter element "+(i+1)+": ");
            arr[i] = sc.nextInt();
        }
        for(int i=0;i<n;i++){
            if(arr[i]>=0 && arr[i]<10) {
                s_d_c++;
            }
            if(arr[i]>=10 && arr[i]<100) {
                d_d_c++;
            }
        }
        System.out.println("Count of single-digit numbers: "+s_d_c);
        System.out.println("Count of double-digit numbers: "+d_d_c);
    }
}

72nd Problem
Write a Java program to find common elements between two integer arrays.
Enter the number of elements in the first array: 3                                                                      
Enter the elements of the first array:                                                                                  
1 2 3                                                                                                                  
Enter the number of elements in the second array: 3                                                                    
Enter the elements of the second array:                                                                                
2 4 3                                                                                                                  
Common elements:                                                                                                        
2                                                                                                                  
3   

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the number of elements in the first array: ");
        int n1 = sc.nextInt();
        System.out.println("Enter the elements of the first array: ");
        int arr1[] = new int[n1];
        for(int i=0;i<n1;i++) {
            arr1[i] = sc.nextInt();
        }
        System.out.print("Enter the number of elements in the second array: ");
        int n2 = sc.nextInt();
        System.out.println("Enter the elements of the second array: ");
        int arr2[] = new int[n2];
        for(int i=0;i<n2;i++) {
            arr2[i] = sc.nextInt();
        }
        System.out.print("Common elements: ");
        for(int i=0;i<n1;i++) {
            for(int j=0;j<n2;j++) {
            if(arr1[i] == arr2[j]) {
                System.out.println(arr1[i]);
                break;
            }
        }
      }
    }
}

73rd Problem
Write a program to store average marks of N students in a single subscripted variables and print the students falling in the following categories in two columns
Average Marks Number of Students
1-30 xx
31-50 xx
51-70 xx
71-85 xx
86-100 xx
sample input output
Enter the number of students: 5                                                                                        
Enter the average marks for each student:                                                                              
Student 1: 55                                                                                                          
Student 2: 65                                                                                                          
Student 3: 65                                                                                                          
Student 4: 89                                                                                                          
Student 5: 34                                                                                                          
Average Marks   Number of Students                                                                                      
1-30            0                                                                                                      
31-50           1                                                                                                      
51-70           3                                                                                                      
71-85           0                                                                                                      
86-100          1      

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the number of students: ");
        int n = sc.nextInt();
        System.out.println("Enter the average marks for each student: ");
        int arr[] = new int[n];
        for(int i=0;i<n;i++) {
            System.out.print("Student "+(i+1)+": ");
            arr[i] = sc.nextInt();
        }
        int[] count = new int[5];
        for(int i=0;i<n;i++) {
        int marks = arr[i];
        if(marks>=1 && marks<=30) {
            count[0]++;
        }
        else if(marks>=31 && marks<=50) {
            count[1]++;
        }
        else if(marks>=51 && marks<=70) {
            count[2]++;
        }
        else if(marks>=71 && marks<=85) {
            count[3]++;
        }
        else if(marks>=86 && marks<=100) {
            count[4]++;
        }
    }
    System.out.println("Average Marks\tNumber of Students");
    System.out.println("1-30\t\t"+count[0]);
    System.out.println("31-50\t\t"+count[1]);
    System.out.println("51-70\t\t"+count[2]);
    System.out.println("71-85\t\t"+count[3]);
    System.out.println("86-100\t\t"+count[4]);
    }
}

74th Problem
Write a Java program to create a class called Shape with methods called getPerimeter() and
getArea(). Create a subclass called Circle that overrides the getPerimeter() and getArea()
methods to calculate the area and perimeter of a circle.
sample input and output
Enter the radius of the circle: 3                                                                                      
Perimeter of the circle: 18.84955592153876                                                                              
Area of the circle: 28.274333882308138

import java.util.*;
class Shape {
    public double getPerimeter() {
        return 0.0;
    }
    public double getArea() {
        return 0.0;
    }
}
class Circle extends Shape {
    private double radius;
    public Circle(double radius) {
        this.radius = radius;
    }
    public double getPerimeter() {
        return 2*Math.PI*radius;
    }
    public double getArea() {
        return Math.PI*radius*radius;
    }
}
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the radius of the circle: ");
        double radius = sc.nextDouble();
        Circle c = new Circle(radius);
        double perimeter = c.getPerimeter();
        double area = c.getArea();
        System.out.println("Perimeter of the circle: "+perimeter);
        System.out.println("Area of the circle: "+area);
    }
}

75th Problem
java program to input array of numbers that contains positive and negative numbers. print count of positive and negative numbers
sample output:
Enter the number of elements in the array: 5
Enter the elements of the array:
1 2 -1 -2 3
Positive Count: 3
Negative Count: 2 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the number of elements in the array: ");
        int n = sc.nextInt();
        int pc = 0;
        int nc = 0;
        System.out.println("Enter the elements of the array: ");
        int arr[] = new int[n];
        for(int i=0;i<n;i++) {
            arr[i] = sc.nextInt();
        if(arr[i]<0) {
            nc++;
        }
        else {
            pc++;
        }
    }
        System.out.println("Positive Count: "+pc);
        System.out.print("Negative Count: "+nc);
    }
}

76th Problem
find sum of even numbers and odd numbers of an input array
Enter the number of elements in the array: 5
Enter the elements of the array:
1 2 3 4 5
Sum of even integers: 6
Sum of odd integers: 9

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the number of elements in the array: ");
        int n = sc.nextInt();
        int esum = 0;
        int osum = 0;
        System.out.println("Enter the elements of the array: ");
        int arr[] = new int[n];
        for(int i=0;i<n;i++) {
            arr[i] = sc.nextInt();
            if(arr[i]%2==0) {
                esum=esum+arr[i];
            }
            else {
                osum = osum + arr[i];
            }
        }
        System.out.println("Sum of even integers: "+esum);
        System.out.print("Sum of odd integers: "+osum);
    }
}

77th Problem
find the duplicate elements from the given array
sample output:
Enter the number of elements in the array: 6                                                                            
Enter the elements of the array:                                                                                        
5 5 3 3 2 1                                                                                                             
Duplicate elements:                                                                                                        
5 3  

import java.util.Scanner;
public class test {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the number of elements in the array: ");
        int length = scanner.nextInt();
        int[] array = new int[length];
        System.out.println("Enter the elements of the array:");
        for (int i = 0; i < length; i++) {
            array[i] = scanner.nextInt();
        }
        int found = 0;
        System.out.println("Duplicate elements: ");
        for(int i=0;i<array.length;i++) {
            if(array[i] == -1) {
                i++;
            }
            for(int j=i+1;j<array.length;j++) {
                if(array[i]==array[j]) {
                  array[j] = -1;
                  found++;   
                }
            }
            if(found!=0 && array[i]!=-1) {
                System.out.print(array[i]+" ");
            }
            found = 0;
        }
    }
}

78th Problem
find the unique elements from the given array
sample output:
Enter the number of elements in the array: 6                                                                            
Enter the elements of the array:                                                                                        
5 5 3 3 2 1                                                                                                             
Unique elements:                                                                                                        
2 1 

import java.util.Scanner;
public class test {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the number of elements in the array: ");
        int length = scanner.nextInt();
        int[] array = new int[length];
        System.out.println("Enter the elements of the array:");
        for (int i = 0; i < length; i++) {
            array[i] = scanner.nextInt();
        }
       System.out.println("Unique elements: ");
       int count = 0;
        for(int i=0;i<array.length;i++) {
            for(int j=i+1;j<array.length;j++) {
                if(array[i] == array[j]) {
                    array[j] = -1;
                    count++;
                }
            }
           if(array[i]!=-1 && count == 0) {
               System.out.print(array[i]+" ");
           }
           count = 0;
        }
    }
}

79th Problem
find the frequency of each element in the given array
sample output:
5
1 2 2 3 4
1-1
2-2
3-1
4-1
sample output2:
6
3 3 3 4 4 4
3-3
4-3 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        int freq = 1;
        for(int i=0;i<n;i++) {
            arr[i] = sc.nextInt();
        }
        for(int i=0;i<n;i++) {
            for(int j=i+1;j<n;j++) {
             if(arr[i] == arr[j]) {
                 arr[j] = -1;
                 freq++;
             }
           }
             if(arr[i]!=-1) {
                 System.out.println(arr[i]+ "-"+freq);
             }
             freq = 1;
        }
    }
}

80th Problem
write a Java Program to Count the Number of Unique Words
Given a string, in which various words are separated by whitespace. Print the count of the unique words 
present in it, that is the words whose frequency is 1.
sample output:
Enter the string                                                                                                        
ava is great C++ is also great                                                                                          
Total number of unique words in "ava is great C++ is also great" are 3                                                  
sample output1:
Enter the string                                                                                                        
good morning                                                                                                            
Total number of unique words in "good morning" are 2

import java.util.*;
class test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the string:");
        String input = sc.nextLine();
        sc.close();
        int uniqueWordCount = 0;
        String[] words = input.split(" ");
        Map<String, Integer> wordCountMap = new HashMap<>();
        //Count the frequency of each word
        for (String word : words) {
            if (!wordCountMap.containsKey(word)) {
                wordCountMap.put(word, 1);
            } else {
                int count = wordCountMap.get(word);
                wordCountMap.put(word, count + 1);
            }
        }
        //Count the number of unique words with frequency 1
        for (String word : wordCountMap.keySet()) {
            if (wordCountMap.get(word) == 1) {
                uniqueWordCount++;
            }
        }
        System.out.println("Total number of unique words in \"" + input + "\" are " + uniqueWordCount);
    }
}

81st Problem
write a java program Remove vowels from a string
sample output:
Enter a string:
welcome
String after removing vowels: wlcm

import java.util.*;
class test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter a string:");
        String input = sc.nextLine();
        sc.close();
        String result = removeVowels(input);
        System.out.println("String after removing vowels: " + result);
    }
    public static String removeVowels(String str) {
        StringBuilder sb = new StringBuilder();
        for (char ch : str.toCharArray()) {
            if (!isVowel(ch)) {
                sb.append(ch);
            }
        }
        return sb.toString();
    }
    public static boolean isVowel(char ch) {
        ch = Character.toLowerCase(ch);
        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';
    }
}

82nd Problem
Java Program tond the largest and smallest word in a string.
sample output
Enter a string:
welcome to ngit college
Smallest word: to
Largest word: welcome  
sample output1
Enter a string:                                                                                                         
hi welcome to fds j1 batch                                                                                               
Smallest word: hi                                                                                                       
Largest word: welcome

import java.util.*;
class test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter a string:");
        String input = sc.nextLine();
        sc.close();
        String[] words = input.split(" ");
        String smallestWord = findSmall(words);
        String largestWord = findLarge(words);
        System.out.println("Smallest word: " + smallestWord);
        System.out.println("Largest word: " + largestWord);
    }
    public static String findSmall(String[] words) {
        String smallestWord = words[0];
        for (int i = 1; i < words.length; i++) {
            if (words[i].length() < smallestWord.length()) {
                smallestWord = words[i];
            }
        }
        return smallestWord;
    }
    public static String findLarge(String[] words) {
        String largestWord = words[0];
        for (int i = 1; i < words.length; i++) {
            if (words[i].length() > largestWord.length()) {
                largestWord = words[i];
            }
        }
        return largestWord;
    }
}

83rd Problem
Given a string, find and remove all the adjacent pairs of repeated characters
sample output:
ABBCCCD
string after removing adjacent pairs of repeated characters: ACD
sample output2:
AAABBBCCDD
string after removing adjacent pairs of repeated characters: AB
sample output3:
AABBBCCDDAXYYZZZZZB
string after removing adjacent pairs of repeated characters: BAXZB

import java.util.*;
class test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String input = sc.nextLine();
        String result = removeAdjacentPairs(input);
        System.out.println("String after removing adjacent pairs of repeated characters: " + result);
    }
    public static String removeAdjacentPairs(String input) {
        StringBuilder sb = new StringBuilder();
        int i = 0;
        while (i < input.length()) {
            if (i < input.length() - 1 && input.charAt(i) == input.charAt(i + 1)) {
                i += 2;
            } else {
                sb.append(input.charAt(i));
                i++;
            }
        }
        return sb.toString();
    }
}

84th Problem
Write a Java program to find longest common prefix of given array of strings.
sample output:
kiran kiranmai kireeti                                                                                                  
The longest Common Prefix is : kir                                                                                       

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        String s [] = str.split(" ");
        Arrays.sort(s);
        String c = "";
        for(int i=0;i<s[0].length();i++) {
            if(s[0].charAt(i)==s[s.length-1].charAt(i)) {
                c=c+s[0].charAt(i);
            }
        }
        System.out.println("The longest Common Prefix is: "+c);
    }
}

85th Problem
program to find first non repeating character in the string
sample output:
aabbcdef
c
sample output2:
abcdeffeda
b 

import java.util.*;
class Test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        char arr[] = str.toCharArray();
        int len = str.length();
        boolean found = false;
        for (int i = 0; i < len; i++) {
            boolean isDuplicate = false;
            for (int j = i + 1; j < len; j++) {
                if (arr[i] == arr[j] && arr[j] != '1') {
                    arr[j] = '1';
                    isDuplicate = true;
                    break;
                }
            }
            if (!isDuplicate) {
                System.out.print(arr[i]);
                found = true;
                break;
            }
        }
        if (!found) {
            System.out.print("No non-repeating character found");
        }
    }
}

86th Problem
find smallest and longest word in the string
sample output:
string programs in java
in
programs 

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        String arr [] = str.split(" ");
        int min = arr[0].length();
        int max = arr[0].length();
        int sindex=0;
        int mindex=0;
        for(int i=0;i<arr.length;i++) {
            if(arr[i].length()<min) {
                min = arr[i].length();
                sindex = i;
            }
            if(arr[i].length()>max) {
                max = arr[i].length();
                mindex = i;
            }
        }
        System.out.println(arr[sindex]);
        System.out.println(arr[mindex]);
    }
}

87th Problem
Write a Java program to check whether a string is a Palindrome or not using pointers
Sample output
Enter a string: madam
The string is a palindrome.
Sample output1:
Enter a string: hello
The string is not a palindrome.

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a string: ");
        boolean p = false;
        String str = sc.nextLine();
        for(int i=0,j=str.length()-1;i<j;i++,j--) {
            if(str.charAt(i) == str.charAt(j)) {
                p = true;
                break;
            }
        }
        if(p == true) {
            System.out.print("The string is a palindrome.");
        }
        else {
            System.out.print("The string is not a palindrome.");
        }
    }
}

88th Problem
Write a java program to check weather two strings are
anagram or not
Anagram
The dictionary meaning of the word anagram is a word or phrase 
formed by rearranging the letters.
Two strings are said to be anagrams if they make a meaningful
word by rearranging or shuffling the letters of the string. 
LISTEN - > SILENT
HEART - > EARTH
LIVES - > ELVIS
KEEP -> PEEK
TABLE - >BLEAT
Sample output:
Enter the first string: HEART
Enter the second string: EARTH
HEART and EARTH are anagrams
sample Output:
Enter the first string: TOSS
Enter the second string: SHOT
TOSS and SHOT are not anagrams

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the first string: ");
        String str1 = sc.next();
        System.out.print("Enter the second string: ");
        String str2 = sc.next();
        int len1 = str1.length();
        int len2 = str2.length();
        int count = 0;
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();
        if(len1 == len2){
            Arrays.sort(s1);
            Arrays.sort(s2);
            for(int i=0;i<len1;i++) {
            if(s1[i] == s2[i]) {
                count++;
            }
            else {
                System.out.print(""+(str1)+" and "+(str2)+" are not anagrams");
                break;
            }
         }
        if(count!=0) {
            System.out.print(""+(str1)+" and "+(str2)+" are anagrams");
        }
    }
        else {
                System.out.print(""+(str1)+" and "+(str2)+" are not anagrams");
        }
    }
}

89th Problem
Write a Java program that finds the number of vowels and consonants in a given sentence
Enter a sentence: welcome to ngit college
Number of vowels: 8
Number of consonants: 12
Sample output1:
Enter a sentence: Good Morning
Number of vowels: 4
Number of consonants: 7

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a sentence: ");
        String str = sc.nextLine();
        int v = 0;
        int c = 0;
        for(int i=0;i<str.length();i++) {
            char ch = str.charAt(i);
            if(ch =='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u') {
                v++;
            }
            else if(ch!=' ') {
                c++;
            }
        }
        System.out.println("Number of vowels: "+v);
        System.out.print("Number of consonants: "+c);
    }
}

90th Problem
Java program that reverses a given word without using the split
Enter a word: how are you
Reversed word: you are how

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a word: ");
        String str = sc.nextLine();
        String arr [] = str.split(" ");
        System.out.print("Reversed word: ");
        for(int i=arr.length-1;i>=0;i--) {
            System.out.print(arr[i]+" ");
        }
    }
}

91st Problem
Java program that reverses a given word without using the split
Enter a word: hello
Reversed word: olleh

import java.util.*;
class test {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a word: ");
        String str = sc.nextLine();
        System.out.print("Reversed word: ");
        for(int i=str.length()-1;i>=0;i--) {
            System.out.print(str.charAt(i));
        }
    }
}

92nd Problem
Write a Java program that swaps two elements in an array list
sample output
Enter the number of elements in the ArrayList: 3
Enter 3 elements:
1
2
3
Enter the index of the first element to swap (0-based): 1
Enter the index of the second element to swap (0-based): 2
Updated ArrayList:
1 3 2

import java.util.ArrayList;
import java.util.Scanner;
public class SwapArrayListElements {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the number of elements in the ArrayList: ");
        int n = scanner.nextInt();
        ArrayList<Integer> arrayList = new ArrayList<>(n);
        System.out.println("Enter " + n + " elements:");
        for (int i = 0; i < n; i++) {
            arrayList.add(scanner.nextInt());
        }
        System.out.print("Enter the index of the first element to swap (0-based): ");
        int firstIndex = scanner.nextInt();
        System.out.print("Enter the index of the second element to swap (0-based): ");
        int secondIndex = scanner.nextInt();
        int temp = arrayList.get(firstIndex);
        arrayList.set(firstIndex, arrayList.get(secondIndex));
        arrayList.set(secondIndex, temp);
        System.out.println("Updated ArrayList:");
        for (int i = 0; i < n; i++) {
            System.out.print(arrayList.get(i) + " ");
        }
    }
}

93rd Problem
Write a java program to read an arraylist of numbers and insert an element 
At the given position
Enter the number of elements in the ArrayList: 5
Enter 5 elements:
10
20
50
70
90
Enter the element to be inserted: 23
Enter the position (0-based) where the element should be 
inserted: 1
Updated ArrayList:
10 23 20 50 70 90 

import java.util.ArrayList;
import java.util.Scanner;
public class InsertArrayListElement {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ArrayList<Integer> arrayList = new ArrayList<>();
        System.out.print("Enter the number of elements in the ArrayList: ");
        int n = scanner.nextInt();
        System.out.print("Enter " + n + " elements:");
        for (int i = 0; i < n; i++) {
            arrayList.add(scanner.nextInt());
        }
        System.out.print("Enter the element to be inserted: ");
        int ele = scanner.nextInt();
        System.out.print("Enter the position (0-based) where the element should be inserted: ");
        int ind = scanner.nextInt();
        arrayList.add(ind, ele);
        System.out.print("Updated ArrayList: ");
        for (int i = 0; i < arrayList.size(); i++) {
            System.out.print(arrayList.get(i) + " ");
        }
    }
}

94th Problem
Write a Java program to update an array element by the given element.
Enter the size of the array: 5
Enter 5 elements:
12
13
45
67
89
Enter the index of the element to be updated (0-based): 3
Enter the new element value: 890
Updated Array: [12, 13, 45, 890, 89]

import java.util.Scanner;
public class UpdateArrayElement {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the size of the array: ");
        int n = scanner.nextInt();
        int[] arr = new int[n];
        System.out.println("Enter " + n + " elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        System.out.print("Enter the index of the element to be updated (0-based): ");
        int index = scanner.nextInt();
        System.out.print("Enter the new element value: ");
        int newElement = scanner.nextInt();
        arr[index] = newElement;
        System.out.println("Updated Array: " + Arrays.toString(arr));
    }
}

95th Problem
Write a Java program to extract a portion of an array list.
sample output
Enter the number of elements in the ArrayList: 6
Enter 6 elements:
12
34
56
78
99
76
Enter the starting index of the portion (0-based): 2
Enter the ending index of the portion (0-based): 5
Extracted Portion: [56, 78, 99, 76]

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
public class ExtractArrayListPortion {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the number of elements in the ArrayList: ");
        int n = scanner.nextInt();
        ArrayList<Integer> arrayList = new ArrayList<>();
        System.out.println("Enter " + n + " elements:");
        for (int i = 0; i < n; i++) {
            arrayList.add(scanner.nextInt());
        }
        System.out.print("Enter the starting index of the portion (0-based): ");
        int startIndex = scanner.nextInt();
        System.out.print("Enter the ending index of the portion (0-based): ");
        int endIndex = scanner.nextInt();
        List<Integer> extractedPortion = arrayList.subList(startIndex, endIndex + 1);
        System.out.println("Extracted Portion: " + extractedPortion);
    }
}

96th Problem
Write a Java program to iterate through all elements in a linked list starting at the specified position.
sample output:
Enter the number of elements in the linked list: 4
Enter 4 elements:
23 90 87 675
Enter the starting position (0-based): 1
Elements in the linked list starting from position 1:
90
87
675 

import java.util.*;
public class IterateLinkedListFromPosition {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the number of elements in the linked list: ");
        int n = scanner.nextInt();
        LinkedList<Integer> linkedList = new LinkedList<>();
        System.out.println("Enter " + n + " elements:");
        for (int i = 0; i < n; i++) {
            linkedList.add(scanner.nextInt());
        }
        System.out.print("Enter the starting position (0-based): ");
        int startIndex = scanner.nextInt();
        System.out.println("Elements in the linked list starting from position " + startIndex + ":");
        for (int i = startIndex; i < linkedList.size(); i++) {
            System.out.println(linkedList.get(i));
        }
    }
}

97th Problem
Write a Java program to insert the specified element at the specified position in the linked list.
Enter the number of elements in the linked list: 6
Enter 6 elements:
100
200
300
560
345
123
Enter the element to be inserted: 567
Enter the position (0-based) where the element should be inserted: 1
Updated Linked List: [100, 567, 200, 300, 560, 345, 123]

import java.util.*;
public class InsertLinkedListElement {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the number of elements in the linked list: ");
        int n = scanner.nextInt();
        LinkedList<Integer> linkedList = new LinkedList<>();
        System.out.println("Enter " + n + " elements:");
        for (int i = 0; i < n; i++) {
            linkedList.add(scanner.nextInt());
        }
        System.out.print("Enter the element to be inserted: ");
        int ele = scanner.nextInt();
        System.out.print("Enter the position (0-based) where the element should be inserted: ");
        int ind = scanner.nextInt();
        linkedList.add(ind, ele);
        System.out.println("Updated Linked List: " + linkedList);
    }
}

98th Problem
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Sample 1:
Input:()[]{}
Output: true
Sample 2:
Input:([)]
Output: false
Constraints:
1 <= s.length <= 104
s consists of parentheses only '()[]{}'.

import java.util.Stack;
public class ValidParentheses {
    public static boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else if (c == ')' && !stack.isEmpty() && stack.peek() == '(') {
                stack.pop();
            } else if (c == '}' && !stack.isEmpty() && stack.peek() == '{') {
                stack.pop();
            } else if (c == ']' && !stack.isEmpty() && stack.peek() == '[') {
                stack.pop();
            } else {
                return false;
            }
        }
        return stack.isEmpty();
    }
    public static void main(String[] args){
        String input1 = "()[]{}";
        String input2 = "([)]";
        System.out.println("Sample 1: " + isValid(input1));
        System.out.println("Sample 2: " + isValid(input2));
    }
}

99th Problem
Imagine you have a basket of apples, each apple representing a number stored in an array called "nums." We want to create another basket called "runningSum" to keep track of the cumulative total of apples as we pick them one by one from the original basket.
To clarify, the runningSum at a specific position 'i' is like counting the total number of apples you have picked from the original basket up to that point, including the apple at position 'i.'
Your task is to determine the number of apples in the runningSum basket at each position 'i' and return the runningSum basket as the final result.
Input Format:
Line-1: A number, size of the array
Line-2: N line separated integers, number of apples
Output Format:
Line-1: Space separated two numbers, indices
Sample Input:
4
1 2 3 4
Sample Output:
1 3 6 10
Sample Input:
5
1 1 1 1 1
Sample Output:
1 2 3 4 5

import java.util.*;
public class Main{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int size = sc.nextInt();
        int[] nums = new int[size];
        for(int i=0;i<size;i++){
            nums[i] = sc.nextInt();
        }
        int[] runningsum = new int[size];
        int sum = 0;
        for(int i=0;i<size;i++){
            sum +=nums[i];
            runningsum[i] = sum;
        }
        for(int i=0;i<size;i++){
            System.out.print(runningsum[i] + " ");
        }
    }
}

100th Problem
In a bag filled with an assortment of coins, each marked with a unique integer value, you are tasked with finding two distinct coins. 
The sum of the values on these two coins should equal a specified target value. 
Your goal is to determine the indices (positions) of these two coins within the bag. 
It is guaranteed that there is exactly one solution to this problem, and each coin can only be used once. 
Input Format:
Line-1: A number, size of the array
Line-2: N line separated integers, coins[]
Line-3: A number, target sum
Output Format:
Line-1: Space separated two numbers, indices
Sample Input:
4
2 7 11 15
9
Sample Output:
0 1
Sample Input:
3
3 2 4
6
Sample Output:
1 2

import java.util.*;
public class Solution {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int sum = sc.nextInt();
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(arr[i] + arr[j] ==sum){
                    System.out.print(i+" "+j);
                    System.exit(0);
                }
            }
        }
    }
  }

101st Problem
A English teacher, would like to present a language challenge. Imagine you have a sentence written with words and spaces. Your task is to determine the length of the final word in this sentence. A word, in this context, is defined as a group of characters without any spaces in between. Your goal is to find the length of the very last word in this sentence.
Input:--------------"Hello World"
Sample Output:---------------5
Sample Input:--------------"fly me   to   the moon  "
Sample Output:---------------4

import java.util.*;
public class Solution{
    public static int lengthoflast(String sentence){
        sentence = sentence.trim();
        String[] words = sentence.split("\\s+");
        String lastword = words[words.length-1];
        return lastword.length();
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String sentence = sc.nextLine();
        int result = lengthoflast(sentence);
        System.out.println(result);
    }
}

102nd Problem
Christina has given a task to break his friends code 
he will given all lower case alphabets  and code as the input 
Christina has to figure the text from the code and display the text 
Input - The first line of input consists of lower case alphabets and code 
The first alphabet letter will given 01, second alphabet will be given 02, and so on 
Output - Break the code and display the string 
Sample Test Case - 1 
input =
abcdefghijklmnopqrstuvwxyz
110525
Explantion - 
From the above test case we have 'a' has '01', 'b' has '02', and finally 'z' has '26' 
where each alphabet will be assigned a two digit number 
and for the code 110525 the characters will be 11 as 'k', 05 as 'e' and 25 as 'y' 
so the output is "key" 
Sample Test Case - 2
input =
qpwoeirutyalskdjfhgzmxncbv
131013090521
output = system
Explantion - From the above test case we have 'q' as '01' , 'p' as '02' and finally 'v' as '26'
and for the code 131013090521 we have the following code 
13-s
10-y
13-s
09-t
05-e
21-m
so the output is system

import java.util.*;
public class Solution{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String word = sc.next();
        String code = sc.next();
        StringBuilder sb = new StringBuilder();
        char str[] = word.toCharArray();
        HashMap<Integer,Character> hm = new HashMap<>();
        for(int i=0;i<str.length;i++){
            hm.put(i+1,str[i]);
        }
        int arr[] = new int[code.length()/2];
        for(int i=0;i<arr.length;i++){
            arr[i] = Integer.parseInt(code.substring(2*i,2*i+2));
        }
        for(int key:arr){
            if(hm.containsKey(key)){
                sb.append(hm.get(key));
            }
        }
        System.out.println(sb);
    }
}

103rd Problem
Sony, a student has given a date by his teacher. 
The teacher taught him the Dates and Calenders in the class today. 
The teacher wants to test the Sony whether he understood or not.
She gives a date to sony and ask to print the following date. 
Help Sony to print the next date. 
Note - If the Date is invalid, Sony has to print -1 
Dont Use Any Pre Defined Date and Time API 
Input - The Input contains the following format "DD-MM-YYYY"
Output - Print the output int the following format "DD-MM-YYYY"
input = 30-11-2000
output = 01-12-2000
input = 31-09-2000
output = -1 
There will be only 30 days in the September month. So prints -1 

import java.util.*;
class test
{
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        String s=sc.next();
        String str[]=s.split("-");
        int day=Integer.parseInt(str[0]);
        int month=Integer.parseInt(str[1]);
        int year=Integer.parseInt(str[2]);
        if(day<0 || day>31 || month<0 || month>12 || year<0)
        {
            System.out.println("-1");
            System.exit(0);
        }
        else
        {
            if(month==2)//feb month
            {
                if(year%4==0)//leap year
                {
                    if(day==29)//29 days
                    {
                        day=1;
                        month=3;
                    }
                    else if(day>29)
                    {
                        System.out.println("-1");
                        System.exit(0);
                    }
                    else//not 29 days
                    {
                        day=day+1;
                    }
                }
                else//not a leap year
                {
                    if(day==28)//28 days
                    {
                        day=1;
                        month=3;
                    }
                    else if(day>28)
                    {
                        System.out.println("-1");
                        System.exit(0);
                    }
                    else//not 28 days
                    {
                        day=day+1;
                    }
                }
            }
            else if(month==1 || month==3 || month==5 || month==7 || month==8 || month==10 || month==12)//31 days
            {
                if(day==31)//31 day
                {
                    if(month==12)//last day of the year
                    {
                        day=1;
                        month=1;
                        year=year+1;
                    }
                    else//other months
                    {
                        day=1;
                        month=month+1;
                    }
                }
                else//not a 31 day
                {
                    day=day+1;
                }
            }
            else
            {
                if(day==30)//30 days
                {
                    day=1;
                    month=month+1;
                }
                else if(day>30)
                {
                    System.out.println("-1");
                    System.exit(0);
                }
                else
                {
                    day=day+1;
                }
            }
            System.out.printf("%02d-%02d-%04d",day,month,year);
        }
    }
}


104th Problem
Ramu is playing a game on a 2D Plane, 
he has given n points with co-ordinates p[i]=(x,y);
He has to visit all the points in the order given by points in minimum time. 
His moves can be as follows.
In 1 second, he can go  vertically by 1 unit,go horizontally by 1 unit, or
go diagonally sqrt(2) units (in other words, go one 1 unit vertically then 1 unit horizontally in 1 second).
he has to visit the points in the same given order as they appear in the given list.
He is also allowed to pass through points that appear later in the order, but these do not count as visits.
Input - The First line of input consists of the Number of Points(n) followed by n points
Sample Test Case - 1
Input = 3
1 1
3 4
-1 0
output = 7
Explanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   
Time from [1,1] to [3,4] = 3 seconds 
Time from [3,4] to [-1,0] = 4 seconds
Total time = 7 seconds
Sample Test Case - 2
Input = 2
3 2
-2 2
output = 5

import java.util.*;
class test
{
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[][]=new int[n][2];
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<2;j++)
            {
                arr[i][j]=sc.nextInt();
            }
        }
        int x=0,y=0,sum=0,count=0;
        for(int i=0;i<n-1;i++)
        {
            x=arr[i][0]-arr[i+1][0];
            y=arr[i][1]-arr[i+1][1];
            if(x==0 || y==0)
            {
                sum=x+y;
                sum=Math.abs(sum);
            }
            else
            {
                sum=x+y;
                sum=(sum/2)+(sum%2);
                sum=Math.abs(sum);
            }
            count=count+sum;
        }
        System.out.println(count);
    }
}

105th Problem
Suman is given two words first word and second word 
he is playing a game to create second word from first word. 
He has to follow the below rules 
        - Replace all the occurrences of a character in first word with any other letter.
	- Repeat the above rule to create secondword from firstword.
	NO two characters in first world should map to same character 
	 Assume both words have same length.
If he is able to do, print "hurray" else print "oh no" 
input = 
paper 
title
output = hurray
Explanation:
'p' is replaced with 't', 'a' is with 'i', 'e' is with 'l', and 'r' with 'e'.
input = 
memo 
demo
output = ohno

import java.util.*;
class test
{
    public static String check(String s1,String s2)
    {
        if(s1.length()!=s2.length())
        {
            return "ohno";
        }
        else
        {
            HashMap<Character,Character> hm=new HashMap<>();
            for(int i=0;i<s1.length();i++)
            {
                char c1=s1.charAt(i);
                char c2=s2.charAt(i);
                if(hm.containsKey(c1))
                {
                    if(hm.get(c1)!=c2)
                    {
                        return "ohno";
                    }
                }
                else
                {
                    hm.put(c1,c2);
                }
            }
            return "hurray";
        }
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        String s1=sc.next();
        String s2=sc.next();
        System.out.println(check(s1,s2));
    }
}


106th Problem
Open AI is working on the below task. 
The task is as follows 
++i
i++
--i
i--
By Default i value is given as '0'
The Open AI has to design the code to give the result for this operations  
Example 1:
Input = --i i++ i++ i++
Output = 1
Explanation: The operations are performed as follows:
Initially, i = 0.
--i: i is decremented by 1, i =  0 - 1 = -1.
i++: i is incremented by 1, i = -1 + 1 =  0.
i++: i is incremented by 1, i =  0 + 1 =  1.
i++: i is incremented by 1, i =  1 + 1 =  2.

import java.util.*;
class test
{
    public static int sum(String s)
    {
        String str[]=s.split(" ");
        int i=0;
        for(int j=0;j<str.length;j++)
        {
            if(str[j].charAt(1)=='+')
            {
                i=i+1;
            }
            else
            {
                i=i-1;
            }
        }
        return i;
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        String s=sc.nextLine();
        System.out.println(sum(s));
    }
}

107th Problem
Dolu has given a Mobile.
His mobile has a special keypad with all alphabets in a same row. 
Initially, Dolus finger is at index 0. 
To type a character, he has to move his finger to the index of the desired character. 
The time taken to move his finger from index i to index j is |i - j|.
Your task is to calculate the time taken for typing the characters on the keypad
The First line of input contains the alphabets(a-z) arranged in random order followed by the word to be typed.
Input = abcdefghijklmnopqrstuvwxyz
cba
Output = 4
Explanation: The index moves from 0 to 2 to write 'c' then to 1 to write 'b' then to 0 again to write 'a'.
Total time = 2 + 1 + 1 = 4. 
input = pqrstuvwxyzabcdefghijklmno 
word = spt
output = 10

import java.util.*;
class test
{
    public static int tsum(String s,String str)
    {
        String word[]=str.split("");
        int sum=0;
        int initial=0;
        for(String a:word)
        {
            int len=s.indexOf(a);
            sum=sum+Math.abs(initial-len);
            initial=len;
        }
        return sum;
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        String s=sc.next();
        String str=sc.next();
        System.out.println(tsum(s,str));
    }
}

108th Problem
Shyam a third class student is a given and date
His teacher asked him to find out the day of the date in the given year.
Help Shyam to solve this problem 
The Input Date Contains DD MM YYYY Format
Assume the Input Date is valid date
input = 31 12 2010
output = 365
input = 01 02 1995
output = 32
1st Feb is 32 Day in the year.
Note - Dont Use Pre Defined Date and Time Class

import java.util.*;
class test
{
    public static int count(int day,int month,int year)
    {
        int days=0;
        int months[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
        if(year%4==0)
        {
            if(year%100==0)
            {
                if(year%400==0)
                {
                    months[2]=29;
                }
                else
                {
                    months[2]=28;
                }
            }
            else
            {
                months[2]=29;
            }
        }
        for(int i=1;i<=month;i++)
        {
            days=days+months[i-1];
        }
        return days+day;
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        int day=sc.nextInt();
        int month=sc.nextInt();
        int year=sc.nextInt();
        System.out.println(count(day,month,year));
    }
}


109th Problem
You are given two strings s1 and s2 of equal length. 
A string swap is an operation where you choose two indices in a string(not necessarily different) and 
swap the characters at these indices.
Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. 
Otherwise, return false.
Sample Input1:
bank
kanb
Sample Output1: 
true
Explanation: For example, swap the first character with the last character of s2 to make "bank".
Sample Input2:
hyderabad
secunderabad
Sample Output2: 
false
Explanation: It is impossible to make them equal with one string swap.
Sample Input3:
kmit
kmit
Sample Output3: 
true
Explanation: The two strings are already equal, so no string swap operation is required.

import java.util.*;
class test
{
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        String s1=sc.nextLine();
        String s2=sc.nextLine();
        String str1[]=s1.split("");
        String str2[]=s2.split("");
        Arrays.sort(str1);
        Arrays.sort(str2);
        int count=0;
        if(str1.length==str2.length)
        {
            for(int i=0;i<str1.length;i++)
            {
                if(str1[i].equals(str2[i]))
                {
                    count=count+1;;
                }
            }
            if(count==str1.length)
            {
                System.out.println("true");    
            }
            else
            {
                System.out.println("false");
            }
        }
        else
        {
            System.out.println("false");
        }
    }
}

110th Problem
Arjun is playing a word game in his tab. When he start the game , It displays a
word and he has to check for any two adjacent characters which are same.If found 
he has to select those two characters by tapping, so that both characters will
be deleted from the word and the word size shrinks by 2. This process to be 
repeated until the word has no two adjacent characters are same.
You task is to help Arjun to perform the above task and Return the final word
obtained.
Input Format:
Line-1: A string represents the word.
Output Format:
Return a string or empty string.
Constraints:
    1 <= word.length <= 10^5   
    word consists only lower case letters.
Sample Input-1:
pqqprs
Sample Output-1:
rs
Explanation:
Initially , Delete two 'q's then the word will be 'pprs'. Now Delete two 'p's 
then the word will be rs.
Sample Input-2:
pqqqprrs
Sample Output-2:
pqps
Explanation:
Initially , Delete two 'q's then the word will be 'pqprrs'. Now Delete two 'r's
then the word will be pqps.

import java.util.*;
class test
{
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        String s=sc.nextLine().toLowerCase();
        Stack<Character> st=new Stack<>();
        for(int i=0;i<s.length();i++)
        {
            char a=s.charAt(i);
            if(st.isEmpty())
            {
                st.push(a);
            }
            else if(st.peek()!=a)
            {
                st.push(a);
            }
            else
            {
                st.pop();
            }
        }
        for(int i=0;i<st.size();i++)
        {
            System.out.print(st.get(i));
        }
    }
}


111th Problem
Mr Somanath is a math teacher. He is given a problem to his students.
The students are given a number N, and the student has to perform following step:
   - Add each digit of the number and add the result to N
Repeat this procedure until N becomes a single digit number.
Your task is to help the students to perform the above steps and 
print the resultant single digit number N.
Input Format:
An integer, number N.
Output Format:
Print an integer result.
Sample Input-1:
95
Sample Output-1:
5
Explanation: 
95 => 9 + 5 = 14
14 => 1 + 4 = 5
Answer is 5
Sample Input-2:
765
Sample Output-2:
9

import java.util.*;
class test {
    static int rsum(int n)
    {
        int sum=0;
        if(n<10)
        {
            return n;
        }
        while(n>0)
        {
            int temp=n%10;
            sum=sum+temp;
            n=n/10;
        }
        return rsum(sum);
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        System.out.println(rsum(n));
    }
}


112th Problem
You are given two strings word1 and word2. Merge the strings by
adding letters in alternating order, starting with word1. 
If a string is longer than the other, append the additional letters onto the 
end of the merged string.
Return the merged string.
Input: word1 = "abc", word2 = "pqr"
Output: "apbqcr"
Explanation: The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r
Input: word1 = "ab", word2 = "pqrs"
Output: "apbqrs"
Explanation: Notice that as word2 is longer, "rs" is appended to the end.
word1:  a   b 
word2:    p   q   r   s
merged: a p b q   r   s
Example 3:
Input: word1 = "abcd", word2 = "pq"
Output: "apbqcd"
Explanation: Notice that as word1 is longer, "cd" is appended to the end.
word1:  a   b   c   d
word2:    p   q 
merged: a p b q c   d

import java.util.*;
class test
{
    public static StringBuilder merge(String s1,String s2)
    {
        StringBuilder sb=new StringBuilder();
        int len=Math.min(s1.length(),s2.length());
        for(int i=0;i<len;i++)
        {
            sb.append(s1.charAt(i));
            sb.append(s2.charAt(i));
        }
        if(s1.length()>s2.length())
        {
            for(int i=len;i<s1.length();i++)
            {
                sb.append(s1.charAt(i));
            }
        }
        else
        {
            for(int i=len;i<s2.length();i++)
            {
                sb.append(s2.charAt(i));
            }
        }
        return sb;
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        String s1=sc.next();
        String s2=sc.next();
        System.out.println(merge(s1,s2));
    }
}

113th Problem
Given a string num which represents an integer, return true if num is a strobogrammatic number.
strobogrammatic number is a number that looks the same when rotated 180 degrees 
(looked at upside down).
Input: num = "69"
Output: true
Example 2:
Input: num = "88"
Output: true
Example 3:
Input: num = "962"
Output: false

import java.util.*;
class test
{
    public static boolean num(String s)
    {
        ArrayList<Integer> arr=new ArrayList<>();
        arr.add(0);
        arr.add(1);
        arr.add(6);
        arr.add(8);
        arr.add(9);
        StringBuilder sb=new StringBuilder();
        for(int i=s.length()-1;i>=0;i--)
        {
            char c=s.charAt(i);
            if(c=='0' || c=='1' || c=='8')
            {
                sb.append(c);
            }
            else if(c=='6')
            {
                sb.append('9');
            }
            else if(c=='9')
            {
                sb.append('6');
            }
            else
            {
                return false;
            }
        }
        if(s.equals(sb.toString()))
        {
            return true;
        }
        return false;
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        String s=sc.next();
        System.out.println(num(s));
    }
}


114th Problem
case =1
input =3
3 2 3
output =3
case =2
input =7
2 2 1 1 1 2 2
output =2
case =3
input =11
2 2 1 1 1 2 2 2 2 2 2
output =2
case =3
input =11
3 3 3 3 3 3 2 2 2 2 2 
output =3
case =4
input =3
7 7 7
output =7

import java.util.*;
class test
{
    public static int max(int n,HashMap<Integer,Integer> hm)
    {
        int max=0;
        for(Map.Entry<Integer,Integer> me:hm.entrySet())
        {
            if(me.getKey()>max)
            {
                max=me.getKey();
            }
        }
        return max;
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        HashMap<Integer,Integer> hm=new HashMap<>();
        for(int i=0;i<n;i++)
        {
            int a=sc.nextInt();
            if(!hm.containsKey(a))
            {
                hm.put(a,1);
            }
            else
            {
                int b=hm.get(a);
                hm.put(a,b+1);
            }
        }
        System.out.println(max(n,hm));
    }
}

115th Problem
Given line, print the string in reverse(use recursion)
Note: don't use reverse() method in stringbuilder)
ex:
input =keshav memorial
output =lairomem vahsek

import java.util.*;
class test
{
    static String rev(String s)
    {
        if(s.isEmpty())
        {
            return s;
        }
        else
        {
            return rev(s.substring(1))+s.charAt(0);
        }
        
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        String s=sc.nextLine();
        System.out.println(rev(s));
    }
}

116th Problem
You are a teacher managing an examination with a set of student IDs 
attending within a specific range [start, end]. 
The list of attending students is sorted and contains unique IDs within this range.
A student ID is considered absent if it falls within the range [start, end] 
but is not present in the attendance list.
Your task is to generate the most concise and organized list of ranges 
that accurately identifies all the absent student IDs. 
These ranges should cover every missing ID within the given range 
and should not include any of the present student IDs in the ranges.
Input Format:
Line 1: start range
Line 2: end range
Line 3: Space separated id's
Output Format:
Ranges of missing id's, refer sample output
Sample Input1:
0
99
0 1 3 50 75
Sample Output1:
[2,2]
[4,49]
[51,74]
[76,99]
Sample Input2:
-1
-1
-1
Sample Output1:
-1
Explanation: There are no missing ranges since there are no missing numbers.
NOTE: Print -1 for boundary conditions

import java.util.*;
class test
{
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        int start=sc.nextInt();
        int end=sc.nextInt();
        sc.nextLine();
        String s=sc.nextLine();
        String str[]=s.split(" ");
        int arr[]=new int[str.length];
        for(int i=0;i<arr.length;i++)
        {
            arr[i]=Integer.parseInt(str[i]);
        }
        int res[]=new int[2];
        if(arr.length==1 || arr[0]==-1)
        {
            System.out.println("-1");
        }
        else
        {
            for(int i=0;i<arr.length;i++)
            {
                if(i==0 && arr[0]>start)
                {
                    res[0]=start;
                    res[1]=arr[i]-1;
                    System.out.println(Arrays.toString(res));
                }
                else if(i>0 && arr[i]-arr[i-1]>1)
                {
                    res[0]=arr[i-1]+1;
                    res[1]=arr[i]-1;
                    System.out.println(Arrays.toString(res));
                }
            }
            if(arr[arr.length-1]<end)
            {
                res[0]=arr[arr.length-1]+1;
                res[1]=end;
                System.out.println(Arrays.toString(res));
            }
            if(arr.length-1==end-start)
            {
                System.out.println("-1");
            }
        }
    }
}

117th Problem
Given an integer num, return the number of steps to reduce it to zero.
In one step, if the current number is even, you have to divide it by 2, 
otherwise, you have to subtract 1 from it.
Sample Input 1:
14
Sample Output 1:
6
Explanation: 
Step 1) 14 is even; divide by 2 and obtain 7. 
Step 2) 7 is odd; subtract 1 and obtain 6.
Step 3) 6 is even; divide by 2 and obtain 3. 
Step 4) 3 is odd; subtract 1 and obtain 2. 
Step 5) 2 is even; divide by 2 and obtain 1. 
Step 6) 1 is odd; subtract 1 and obtain 0.
Sample Input 2:
8
Sample Output 2: 
4
Explanation: 
Step 1) 8 is even; divide by 2 and obtain 4. 
Step 2) 4 is even; divide by 2 and obtain 2. 
Step 3) 2 is even; divide by 2 and obtain 1. 
Step 4) 1 is odd; subtract 1 and obtain 0.

import java.util.*;
class test
{
    public static int count(int n)
    {
        if(n==0)
        {
            return 0;
        }
        else if(n%2==0)
        {
            return 1+count(n/2);
        }
        else
        {
            return 1+count(n-1);
        }
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        System.out.println(count(n));
    }
}

118th Problem
There is a switch-board made by an electrician,
If you turn on any two adjacent switches, it will cause short-circuit
and damage the switch-board.
You are given N integers(only 0's and 1's), Indiactes current status of the switch board with N switches,
where 1 indiactes switch is ON and 0 indiactes switch is OFF. 
And an integer K, more number of switches to be turned ON.
Return true if and only if you can turn ON all the K switches, without causing any damage to switch-board.
Otherwise return fasle.
Input Format:
Line-1: Two integers N and K, number of switches, and more number of switches to be ON
Line-2: N space separated integers, only 0's and 1's.
Output Format:
Print a boolean value.
Sample Input-1:
5 1
1 0 0 0 1
Sample Output-1:
true
Sample Input-2:
5 2	
1 0 0 0 1
Sample Output-2:
false

import java.util.*;
class test
{
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int a=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)
        {
            arr[i]=sc.nextInt();
        }
        int count=0;
        for(int i=1;i<n-1;i++)
        {
            if(arr[i-1]==0 && arr[i]==0 && arr[i+1]==0)
            {
                arr[i]=1;
                count++;
            }
        }
        if(count>=a)
        {
            System.out.println("true");
        }
        else
        {
            System.out.println("false");
        }
    }
}

119th Problem
write a program to check, the given string is palindrome or not
Note: write the logic using recrusion only
ex:
input =liril
output =true
input =lirrli
output =false

import java.util.*;
class test
{
    public static boolean palindrome(String s)
    {
        StringBuilder sb=new StringBuilder(s);
        if(s.length()==1 || s.length()==0)
        {
            return true;
        }
        if(s.charAt(0)==s.charAt(s.length()-1))
        {
            return palindrome(s.substring(1,s.length()-1));
        }
        return false;
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        String s=sc.nextLine();
        System.out.println(palindrome(s));
    }
}

120th Problem
Write an algorithm to determine if a number n is magic number or not
A Magic number is a number defined by the following process:
1) Starting with any positive integer, replace the number by the sum of the squares of 
its digits.
2) Repeat the process until the number equals 1 (where it will stay), or 
it loops endlessly in a cycle which does not include 1.
3) Those numbers for which this process ends in 1 are magic number.
Return true if n is a Magic number, and false if not.
Input: n = 19
Output: true
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
Input: n = 2
Output: false

import java.util.*;
class test
{
    public static boolean magic(int n)
    {
        int sum=0;
        if(n==1 || n==7)
        {
            return true;
        }
        else if(n<10)
        {
            return false;
        }
        else
        {
            while(n!=0)
            {
                int temp=n%10;
                sum=sum+(temp*temp);
                n=n/10;
            }
            return magic(sum);
        }
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        System.out.println(magic(n));
    }
}

121st Problem
You are provided with a string composed of binary digits, and 
your task is to write a method that calculates the count of set bits within it. 
Input Format:
A string, consists of 0's and 1's.
Output Format:
Print an integer result.
01001100001111101101010101111000
Sample Output:
17
11110010111011011011011111100110
Sample Output:
22

import java.util.*;
class test {
    public static int count(String s){
        int c=0;
        if(s.length()==0)
        {
            return 0;
        }
        if(s.charAt(0)=='1')
        {
            c++;
        }
        return c+count(s.substring(1));
        
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        String s=sc.next();
        System.out.println(count(s));
    }
}

122nd Problem
Keshav Memorial University has the following grading policy:
Every student receives a  in the inclusive range from  0 to 100.
Any grade less than 40 is a failing grade.
Sam is a professor at the university and likes to round each student's grade according to these rules:
If the difference between the grade and the next multiple of  5 is less than 3, round grade up to the next multiple of 5.
If the value of grade is less than 38, no rounding occurs as the result will still be a failing grade.
Examples
grade = 84 round to 85 (85 - 84 is less than 3)
grade = 29 do not round (result is less than 40)
grade = 57 do not round (60 - 57 is 3 or higher)
Given the initial value of  for each of Sam's  students, write code to automate the rounding process.
Input Format:
Line 1: The number of students.
Line 2: Each line  of the  subsequent lines contains a single integer, grades[i].
Sample Input:
4
73
67
38
33
Sample Output:
75
67
40
33

import java.util.*;
class test
{
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)
        {
            arr[i]=sc.nextInt();
        }
        for(int i=0;i<n;i++)
        {
            if(arr[i]>=38)
            {
                if((arr[i]+1)%5==0)
                {
                    arr[i]=arr[i]+1;
                }
                else if((arr[i]+2)%5==0)
                {
                    arr[i]=arr[i]+2;
                }
            }
        }
        for(int i=0;i<n;i++)
        {
            System.out.println(arr[i]);
        }
    }
}

123rd Problem
A space explorer's ship crashed on Mars! They send a series of SOS messages to Earth for help.
Letters in some of the SOS messages are altered by cosmic radiation during transmission. 
Given the signal received by Earth as a string, S , determine how many letters of the SOS message have been changed by radiation.
Example
S = SOSTOT
The original message was SOSSOS. Two of the message's characters were changed in transit.
Input Format:
Line 1: A single string, S.
Output Format:
Line 1: An integer.
Sample Input 1:
SOSSPSSQSSOR
Sample Output 1:
3
Explanation:
S = SOSSPSSQSSOR, and signal length is 12. They sent 4 SOS messages (i.e.:12/3 = 4).
Expected signal: SOSSOSSOSSOS
Recieved signal: SOSSPSSQSSOR
Difference:          X  X   X
Sample Input 2:
SOSSOT
Sample Output 2:
1
Sample Input 3:
SOSSOSSOS
Sample Output 3:
0
Explanation:
Since no character is altered, return 0.

import java.util.*;
class test
{
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        String s=sc.nextLine().toUpperCase();
        int len=s.length()/3;
        int count=0;
        String a="SOS".repeat(len);
        for(int i=0;i<s.length();i++)
        {
            if(s.charAt(i)!=a.charAt(i))
            {
                count++;
            }
        }
        System.out.println(count);
    }
}

124th Problem
In a shopping mall, there is a Lift with a capacity of 500kgs only.
There are N persons waiting for the lift, and their weights (weights[]) are given.
If The Lift is overloaded, it will not move.
Your task is to find out the maximum number of persons can use the Lift,
without any overloading issue
Input Format:
Line-1: An integer N, number of persons
Line-2: N space separated integers, weights of the persons.
Output Format:
Print an integer, max num of persons canuse the lift.
Sample Input-1:
6
98 121 76 135 142 65
Sample Output-1:
5
Sample Input-2:
7
85 67 69 83 54 61 50
Sample Output-2:
7

import java.util.*;
class test
{
    public static int max(int arr[],int n)
    {
        Arrays.sort(arr);
        int sum=0;
        int c=0;
        for(int i=0;i<n;i++)
        {
            if(sum+arr[i]<500)
            {
                sum=sum+arr[i];
                c++;
            }
        }
        return c;
    }
    public static void main (String[] args)
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)
        {
            arr[i]=sc.nextInt();
        }
        System.out.println(max(arr,n));
    }
}

125th Problem
MotorSport Ltd hosting a Racing Championship. Mr. Ajith is participating 
in car races. Each race start and end in perticular time intervals.
You are given an array of racing time intervals consisting of
start and end times [[s1,e1],[s2,e2],...] (s < e ) of N races, in which 
Ajith has to participate. Your task is to determine whether Ajith can 
in all the races or not.
NOTE: If a race starts at time 'a' ends at time 'b', 
another race can start at 'b'.
Input Format:
Line-1: An integer N, number of races Ajith has to participate.
Next N lines: Two space separated integers, start and end time of each race.
Output Format:
Print a boolean value.
Sample Input-1:
3
0 30
5 10
15 20
Sample Output-1:
false
Sample Input-2:
3
0 10
15 25
30 35
Sample Output-2:
true

import java.util.*;
class test
{
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[][]=new int[n][2];
        for(int i=0;i<n;i++)
        {
            arr[i][0]=sc.nextInt();
            arr[i][1]=sc.nextInt();
        }
        Arrays.sort(arr,(a,b)->a[1]-b[1]);
        boolean win=true;
        int end=arr[0][1];
        for(int i=1;i<n;i++)
        {
            if(arr[i][0]<end)
            {
                win=false;
                break;
            }
            else
            {
                end=arr[i][1];
            }
        } 
        System.out.println(win);
    }
}

126th Problem
Mark is a class 9 student. His class teacher Betty, gives him a match box 
containing match sticks of variable lengths. Betty asks Mark to form an object 
in the form of a triangle and return the maximum perimeter that can be formed 
from those match sticks. If he cannot form the given object, he has to 
communicate back to Betty by sending a value 0.
Sample test case
case=1
input=5
7 2 3 4 12
output=9
Explanation:
Input: line1 is number of elements, followed by value for the elements in line2
Output: 9
case=2
input=5
8 1 2 3 5
output=0
case=3
input=6
1 3 2 4 7 14
output=9
case=4
input=5
5 3 15 8 4
output=17
case=5
input=7
4 3 6 5 2 8 7 
output=21

import java.util.*;
class test {
    public static int triangle(int arr[],int n) {
        Arrays.sort(arr);
        if(n<3) {
           return 0;
        }
        else {
            for(int i=n-1;i>1;i--) {
                if(arr[i-2]+arr[i-1]>arr[i])
                {
                    return arr[i-2]+arr[i-1]+arr[i];
                }
            }
        }
        return 0;
    }
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)
        {
            arr[i]=sc.nextInt();
        }
        System.out.println(triangle(arr,n));
    }
}

127th Problem
King Arthur is stuck in the battlefield and sends message to his general David 
to rescue him. The message has the king’s location “base” (x,y) on a map which 
is in the form of cartesian coordinate system. King’s army units are placed at 
different location (x1, y1), (x2, y2) … (xn, yn) on the map. His general David 
has to figure out the minimum distance between the “base” and the army units 
and accordingly dispatch the unit which is the closest. The distance between 
the “base” and any army unit is calculated as absolute distance between the 
army unit location and base location, i.e. for first army unit (x1,y1), the 
absolute distance is |x1-x| + |y1-y\, for second unit (x2,y2), 
it is |x2-x| + |y2-y\ and so on.
The army unit has to be on the same line (horizontal or vertical) with that of 
the “base” location for the dispatch. Given a list of location of army units 
and the kings location (base), David has to provide the index of the unit he 
plans to dispatch. If two units have the same distance from the “base”, he has 
to provide the index of the unit that comes first in the list. If there are no 
units that can be dispatched then return -1. Your task is to help David in his 
task.
Input: 6
1 1
2 3
3 1
2 4
1 2
4 4
3 4 (base)
Output: 3
Explanation:
Input: line1 is number of points, followed by value for those points, followed 
by base point (x,y)
Output: 3
In the given points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, 
[2,4] and [4,4] have the smallest valid distance from base location, with a 
distance of 1. [2,4] has the smallest index, so return 3.
case=2
input=5
2 3
3 1
2 4
1 2
4 4
3 4
output=2
case=3
input=1
2 5
2 5
output=0
case=4
input=1
3 4
4 5
output=-1
case=5
input=6
4 4
1 1
2 3
3 1
2 4
1 2
3 4
output=0

import java.util.*;
class test
{
    public static int find(int arr[][],int x,int y)
    {
        int index=-1;
        int min=Integer.MAX_VALUE;
        for(int i=0;i<arr.length;i++)
        {
            int xd=arr[i][0];
            int yd=arr[i][1];
            int dis=Math.abs(xd-x)+Math.abs(yd-y);
            if((xd==x || yd==y) && dis<min)
            {
                min=dis;
                index=i;
            }
        }
        return index;
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[][]=new int[n][2];
        for(int i=0;i<n;i++)
        {
            arr[i][0]=sc.nextInt();
            arr[i][1]=sc.nextInt();
        }
        int x=sc.nextInt();
        int y=sc.nextInt();
        int close=find(arr,x,y);
        System.out.println(close);
    }
}

128th Problem
John loves shopping. He has some money in his purse and wants to buy few items. 
He is given a list of prices for the items and the amount to buy the items. The 
prices are arranged in non-decreasing order. With the amount he has, he can 
either buy any two items with no money left or no item at all. When he is able 
to buy two items, he wants to know the index of the selected items. If no items 
are purchased, return empty list. Your task is to help John in her task.
Sample test case
case=1
input=5
2 5 7 11 15
9
output=[0, 2]
case=2
input=5
2 5 7 11 15
14
output=[]
case=3
input=10
1 2 3 4 5 6 7 8 9 10
11
output=[0, 9]
case=4
input=6
2 3 4 4 5 6
8
output=[0, 5]

import java.util.*;
class test
{
    public static String sum(int arr[],int n,int target)
    {
        for(int i=0;i<n;i++)
        {
            for(int j=n-1;j>=0;j--)
            {
                if(arr[i]+arr[j]==target)
                {
                    res.add(i);
                    res.add(j);
                    return res.toString();
                }
            }
        }
        return res.toString();
    }
    public static void main (String[] args) 
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)
        {
            arr[i]=sc.nextInt();
        }
        int target=sc.nextInt();
        System.out.println(sum(arr,n,target));
    }
}

129th Problem
The school management has planned few games for students to improve their 
mathematical skills,one such game is group of students are placed in a row, 
first student holds a number 0, second student holds a number 1, and 
the task is remaining students have to hold the number which is equal to 
the addition of previous two student's numbers. With your programming skills 
can you print the numbers to be hold by students for a given group contains 
n students. 
Example 1:
input:3
Output: 0 1 1
Example 2:
Input:7
Output: 0 1 1 2 3 5 8 

import java.util.*;
class Game {
    public static int fibonacci(int n){
        if(n==0)
        {
            return 0;
        }
        else if(n==1)
        {
            return 1;
        } 
        else 
        {
            return fibonacci(n-1)+fibonacci(n-2);
        }
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for(int i=0;i<n;i++){
            System.out.print(fibonacci(i)+" ");
        }
    }
}

130th Problem
In a primary school mathematics teacher has given a task to students, i.e multiply all the integers between 1 to n and give the final product.With a pen and paper, this process has taken much more time,and you are thier computer teacher can you help students by giving a program to solve this task.
input format = integer
output format = integer
Example 1:
input=5
output=120
Example 2:
input=6
output=720
Example 3:
input=8
output=40320 

import java.util.*;
class Product {
    public static int fact(int n){
        if(n==0){
            return 1;
        }
        else if(n==1){
            return 1;
        }
        else {
            return n*fact(n-1);
        }
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int result = fact(n);
        System.out.print(result);
    }
}

131st Problem
You are attending an interview interviewer asked you to print 1 to n numbers 
without using loops when given an integer N.
input format : an integer n
Examples:
Input: N = 5
Output: 1 2 3 4 5
Explanation: We have to print numbers from 1 to 5.
Input: N = 10
Output: 1 2 3 4 5 6 7 8 9 10
Explanation: We have to print numbers from 1 to 10.

import java.util.*;
class PrintNumbers{
    public static int print(int a){
        if(a==1){
            return 1;
        }
        else if(a==0){
            return 0;
        }
        else {
            return 1+print(a-1);
        }
    }
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for(int i=1;i<=n;i++){
            System.out.print(print(i)+" ");
        }
    }
}

132nd Problem
you are solving a puzzle, which is to find product of two integers without 
using multiplication operator and without using any loops.
Using your programming skills can you solve this with a java program.
Example1 :
input =4 5
output=20
Example 2:
input=6 15
output=90 

import java.util.*;
class ProductOfTwo{
    public static int mul(int a, int b){
        if(a==0 || b==0){
            return 0;
        }
        else {
            return a+mul(a,b-1);
        }
    }
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        System.out.println(mul(a,b));
    }
}

133rd Problem
you are writing an exam, the question is to test a given string is palindrome or not, but the constraints are,should not use builtin functions like reverse and any loops. 
Example 1:
input=abcdedcba
output=true
Example 2:
input=abcdefdcba
output=false

import java.util.*;
class StringPalindrome {
    public static boolean pal(String s){
        if(s.length()==1){
            return true;
        }
        else {
            if(s.charAt(0) == s.charAt(s.length()-1)){
                return pal(s.substring(1,s.length()-1));
            }
        }
        return false;
    }
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        System.out.print(pal(s));
    }
}

134th Problem
Given a string s and a character letter, return the percentage of characters 
in s that equal letter rounded down to the nearest whole percent.
input format : string 
               single character
output format : integer number
Example 1:
Input:foobar
o
Output: 33
Explanation:
The percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33.
Example 2:
Input:jjjj
k
Output: 0
Explanation:
The percentage of characters in s that equal the letter 'k' is 0%, so we return 0.

import java.util.*;
class Percentage{
    public static int percentage(String s, char letter){
        int cnt = 0;
        int n = s.length();
        for(int i=0;i<n;i++){
            char a = s.charAt(i);
            if(a==letter){
                cnt++;
            }
        }
            int pcnt = (cnt*100)/n;
            return pcnt;
    }
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        char c = sc.next().charAt(0);
        System.out.println(new Percentage().percentage(str,c));
    }
}

135th Problem
import java.util.*;
class Solution 
{
    public String reformatNumber(String number) 
	{
		System.out.println("String length before removal is   "+number.length());
        number = number.replace("-", "").replace(" ", "");
		System.out.println("String length after removal is   "+number.length());
        int length = number.length();
        if (length < 4) {
            return number;
        }
        StringBuilder formatted = new StringBuilder(number);
        int index = 3;
        while (length > 4) 
		{
            formatted.insert(index, "-");
            index += 4;
            length -= 3;
        }
        if (length == 4) 
		{
            index -= 1;
            formatted.insert(index, "-");
        }
        return formatted.toString();
    }
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		String str=sc.nextLine();
		System.out.println(new Solution().reformatNumber(str));
	}
}

136th Problem
Given two arrays Aand B, B is an anagram of A. B is an anagram of A means B is made by randomizing the order of the elements in A.
We want to find an index mapping P, from A to B. 
A mapping P[i] = j means the ith element in A appears in B at index j.
Note:  The lists A and B doesn't contain duplicates. 
       A, B have equal lengths in range [1, 100].
       If the array doesnt contains the elements print -1 in the place of index 
input = 5
12 28 46 32 50
50 12 32 46 28
output =
1 4 3 2 0
Explanation
as res[0] = 1 because the 0th element of A appears at B[1], 
and res[1] = 4 because the 1st element of A appears at B[4], 
and so on.

import java.util.*;
public class Solution{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] A = new int[n];
        int[] B = new int[n];
        for (int i = 0; i < n; i++) {
            A[i] = sc.nextInt();
        }
        for (int i = 0; i < n; i++) {
            B[i] = sc.nextInt();
        }
        sc.close();
        int[] P = findIndexMapping(A, B);
        for (int i = 0; i < n; i++) {
            System.out.print(P[i] + " ");
        }
        System.out.println();
    }
    public static int[] findIndexMapping(int[] A, int[] B) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < B.length; i++) {
            map.put(B[i], i);
        }
        int[] P = new int[A.length];
        for (int i = 0; i < A.length; i++) {
            if (map.containsKey(A[i])) {
                P[i] = map.get(A[i]);
            } else {
                P[i] = -1;
            }
        }
        return P;
    }
}

137th Problem
You are given a 0-indexed integer array nums.
In one operation, you may do the following:
1) Choose two integers in nums that are equal.
2) Remove both integers from nums, forming a pair.
3) The operation is done on nums as many times as possible.
Return a 0-indexed integer array answer of size 2 where answer[0] is the number 
of pairs that are formed and answer[1] is the number of leftover integers 
in nums after doing the operation as many times as possible.
Example 1:
Input: nums = 
7
1 3 2 1 3 2 2
output =3 1
Explanation:
Form a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2]
Form a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2]
Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2]
No more pairs can be formed. 
A total of 3 pairs have been formed, and there is 1 number leftover in nums.

import java.util.*;
public class Solution{
    public static int[] findPairsAndLeftovers(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        int[] answer = new int[2];
        for (int value : map.values()) {
            answer[0] += value / 2;
            answer[1] += value % 2;
        }
        return answer;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = sc.nextInt();
        }
        sc.close();
        int[] answer = findPairsAndLeftovers(nums);
        System.out.println(answer[0] + " " + answer[1]);
    }
}

138th Problem
BINARY SEARCH
import java.util.*;
class File {
    public static boolean bs(int arr[], int target) {
        int low = 0;
        int high = arr.length - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (target == arr[mid]) {
                return true;
            } else if (target < arr[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter Size: ");
        int n = sc.nextInt();
        int arr[] = new int[n];
        System.out.println("Enter Array elements: ");
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        System.out.println("Enter Target: ");
        int target = sc.nextInt();
        System.out.println(bs(arr, target));
    }
}

139th Problem
Given a m x n matrix grid which is sorted in non-increasing order 
both row-wise and column-wise, return the number of negative numbers in grid.
Example 1:
Input: 4 4
4 3 2 -1 
3 2 1 -1
1 1 -1 -2
-1 -1 -2 -3
Output: 8
Explanation: There are 8 negatives number in the matrix.
Example 2:
Input: 2 2
3 2 
1 0
Output: 0

import java.util.*;
class CountNegative 
{
    public static int bs(int arr[]) {
	    int low = 0;
	    int high = arr.length-1;
	    while(low<=high){
	        int mid = (low+high)/2;
	        if(arr[mid]>=0){
	            low = mid+1;
	        }
	        else {
	            high = mid-1;
	        }
        }
	        return arr.length-low;
    }
    public int countNegatives(int[][] grid) {
        int cnt = 0;
        for(int arr[] :grid){
            cnt = cnt+bs(arr);
        }
            return cnt;
    }
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		int m = sc.nextInt();
        int n = sc.nextInt();
        int[][] arr = new int[m][n];
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                arr[i][j] = sc.nextInt();
		System.out.println(new CountNegative().countNegatives(arr));

	}
}

140th Problem
Mr. Ram is working in a manufacturing industry where items with different weights are manufactured.
His duty is to pick pairs of items whose weight difference is equal to 'k'. 
Can you help him with a program? The condition is not to use extra space.
input format:an integer number n
			 n number of positive integers
			 an integer number k
output format : pairs of integers
Example 1:
input = 8
1 2 3 4 5 6 7 8
3
output =
1 4
2 5
3 6
4 7
5 8
Example 2:
input = 10
5 10 15 20 25 30 35 40 45 50
5
output =5 10
10 15
15 20
20 25
25 30
30 35
35 40
40 45
45 50 

import java.util.*;
public class FindPairsWithDifference 
{
	private static void findPairsWithDifference(int[] array, int k) 
	{
        for(int i=0;i<array.length;i++)
        {
                int ans = bs(array,i+1,array.length-1,array[i]+k);
                if(ans != -1)
                {
                System.out.println(array[i]+" "+ans);
            }
        }
    }
    private static int bs(int[] array, int low, int high, int target) 
	{
	    Arrays.sort(array);
        while(low<=high){
            int mid=(low+high)/2;
            if(target == array[mid]){
                return array[mid];
            }
            else if(array[mid] < target){
                low = mid+1;
            }
            else{
                high = mid-1;
            }
        }
        return -1;
    }
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] array = new int[n];
		for(int i=0;i<n;i++)
			array[i]=sc.nextInt();
        int k = sc.nextInt();
        findPairsWithDifference(array, k);
    }
}

141st Problem
Mr Ravi is a business man, he does business weekly Q times, 
and records his PROFIT or LOSS every time in to data[][] array. 
He records the LOSS as a negative value and PROFIT as a positive value.
Your task is to help Mr Ravi to know that how many total number of times,
he was in LOSS after P weeks.
NOTE: The values in data[][] are in descending order both row-wise and 
column-wise as given in sample testcases.
Input Format:
Line-1: Two space separated integers, P and Q
Next P lines: Q space separated integers, data[][].   
Output Format:
Print an integer result.
Sample Input-1:
4 4
5 4 2 -2
4 3 1 -2
2 2 -1 -3
-1 -1 -2 -4
Sample Output-1: 
8
Explanation: 
8 days in LOSS,since there are 8 negative values.
Sample Input-2:
4 4
8 7 1 -2
7 6 2 -3
3 -1 -2 -4
-2 -3 -4 -7
Sample Output-2:
9
Explanation:
9 days in LOSS,since there are 8 negative values.
Sample Input-3:
2 2
9 3
5 0
Sample Output-3:
0

import java.util.Scanner;
public class Solution{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int P = sc.nextInt();
        int Q = sc.nextInt();
        int lossDays = 0;
        for (int i = 0; i < P; i++) {
            for (int j = 0; j < Q; j++) {
                int value = sc.nextInt();
                if (value < 0) {
                    lossDays++;
                }
            }
        }
        System.out.println(lossDays);
    }
}

142nd Problem
You have a set of integers s, 
which originally contains all the numbers from 1 to n. 
Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, 
which results in repetition of one number and loss of another number.
You are given an integer array nums representing the data status of this set 
after the error.
Find the number that occurs twice and the number that is missing.
Input Format:
Line-1: An integer, n, size of array
Line-2: Space separated integers.   
Output Format:
Line-1: Space separated numbers, duplicate and missing number
Sample Input-1:
4
1 2 2 4
Sample Output-1:
2 3
Sample Input-2:
2
1 1
Sample Output-2:
1 2

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = sc.nextInt();
        }
        int duplicate = -1;
        int missing = -1;
        for (int num : nums) {
            int abs = Math.abs(num);
            if (nums[abs - 1] > 0) {
                nums[abs - 1] *= -1;
            } else {

                duplicate = abs;
            }
        }
        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) {
                missing = i + 1;
                break;
            }
        }
        System.out.println(duplicate + " " + missing);
    }
}

143rd Problem
Given a sorted list of integers, 
Your task is to find the continuous range of numbers, make them as groups
and print all the groups as show in the sample testcases.
For example:
Given list is [ 1, 2, 3 ]: 1, 2, 3 is continuous range, grouped as 1->3
Given list is [ 1, 2, 4, 5, 7 ]: 1, 2 is continuous range, grouped as 1->2, 
4,5 grouped as 4->5, 7 is left alone.
Note: List contain no duplicates.
Input Format:
Line-1 -> Space separated integers in sorted order
Output Format:
Print the list of continuous range groups.
Sample Input-1:
5
1 2 4 5 7
Sample Output-1:
[1->2, 4->5, 7]
Explanation: 
1,2 form a continuous range; 4,5 form a continuous range.
Sample Input-2:
9
1 2 3 5 6 7 9 10 12
Sample Output-2:
[1->3, 5->7, 9->10, 12]
Explanation: 
1,2,3 form a continuous range 
5,6,7 form a continuous range
9,10 form a continuous range

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = sc.nextInt();
        }
        String groups = "[";
        int start = nums[0];
        int end = nums[0];
        for (int i = 1; i < n; i++) {
            if (nums[i] == nums[i-1] + 1) {
                end = nums[i];
            } else {
                
                if (start == end) {
                    groups += start + ", ";
                } else {
                    groups += start + "->" + end + ", ";
                }
                start = nums[i];
                end = nums[i];
            }
        }
        if (start == end) {
            groups += start + "]";
        } else {
            groups += start + "->" + end + "]";
        }
        System.out.println(groups);
    }
}

144th Problem
Given an array of distinct integers arr, where arr is sorted in ascending order, 
return the smallest index i that satisfies arr[i] == i. If there is no such index,
return -1.
input =5
-10 -5 0 3 7
output =3
Explanation: For the given array, arr[0] = -10, arr[1] = -5, arr[2] = 0, arr[3] = 3, thus the output is 3.
input =5
0 2 5 8 17
output =0
Explanation: arr[0] = 0, thus the output is 0.
input =6
-10 -5 3 4 7 9
output = -1
Explanation: There is no such i that arr[i] == i, thus the output is -1.

import java.util.Scanner;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        int result = -1;
        int left = 0;
        int right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == mid) {
                result = mid;
                right = mid - 1;
            } else if (arr[mid] > mid) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        System.out.println(result);
    }
}

145th Problem
You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.
We repeatedly make duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.
Example 1:
Input: s = "abbaca"
Output: "ca"
Explanation: 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
Example 2:
Input: s = "azxxzy"
Output: "ay"
input =acaaabbbacdddd
output =acabac
input =abbbaca
output =abaca

import java.util.*;
public class Solution{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        System.out.println(removeDuplicates(s));
    }
    public static String removeDuplicates(String s) {
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (sb.length() > 0 && sb.charAt(sb.length() - 1) == c) {
                sb.deleteCharAt(sb.length() - 1);
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }
}

146th Problem
Vihan is given a number N and He wants to check whether N is a converse number
or not. The binary form of number N is said to be converse number, if it obeys 
the following property: "every pair of adjacent digits are different". 
Your task is to help Vihan to find N is a converse number or not.
If yes, print 'true', otherwise print 'false'.
Input Format:
An integer N, the positive number.
Output Format:
Print a boolean result.
Sample Input-1:
85
Sample Output-1:
true
Explanation:
Binary Rep of 85 is 1010101 
Sample Input-2:
87
Sample Output-2:
false
Explanation:
Binary Rep of 87 is 1010111

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        String binary = Integer.toBinaryString(N);
        boolean isConverse = true;
        for (int i = 0; i < binary.length() - 1; i++) {
            if (binary.charAt(i) == binary.charAt(i + 1)) {
                isConverse = false;
                break;
            }
        }
        System.out.println(isConverse);
    }
}

147th Problem
Ramu has been given two different sets of students marks.
His teacher has been surprised to see that few of these marks of two sets seems to be similar.
If they are equal the teacher gives Grade 'Equal' to both the sets
If they are not equal the teacher gives Grade 'Not Equal' to both the sets
Input 
The first line of input contains the size of set1 followed by set1 elements followed by set2 size followed by set2 elements
Input = 
5
1 2 3 4 5
5
4 3 2 1 5
Output = Equal
Input =
6
1 2 3 2 1 4
6
1 2 3 2 4 4
Output = Not Equal
Help Ramu to fix the problem. 

import java.util.*;
public class Solution{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n1 = sc.nextInt();
        HashSet<Integer> set1 = new HashSet<>();
        for (int i = 0; i < n1; i++) {
            set1.add(sc.nextInt());
        }
        int n2 = sc.nextInt();
        HashSet<Integer> set2 = new HashSet<>();
        for (int i = 0; i < n2; i++) {
            set2.add(sc.nextInt());
        }A
        boolean result = set1.equals(set2);
        if (result) {
            System.out.println("Equal");
        } else {
            System.out.println("Not Equal");
        }
    }
}

148th Problem
In a Militarty Organization, the Army chief wants to write the names of the soldiers in the reverse order and 
check the names(reversed) with the orginal names.
Help the chief to check how many such names are equal. 
Print the names which are equal. 
If they are not equal print -1
Note - Use Recursion Only
input = thomas hah abcddcba
output = hah abcddcba
input = a b c d
output = a b c d
input = shiva gopi hari
output = -1

import java.util.Scanner;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String names = sc.nextLine();
        String[] arr = names.split(" ");
        int count = 0;
        for (String name : arr) {
            String reversed = reverse(name);
            if (name.equals(reversed)) {
                count++;
                System.out.print(name + " ");
            }
        }
        if (count == 0) {
            System.out.println(-1);
        }
    }
    public static String reverse(String str) {
        if (str.isEmpty() || str.length() == 1) {
            return str;
        }
        return str.charAt(str.length() - 1) + reverse(str.substring(0, str.length() - 1));
    }
}

149th Problem
Steve Jobs is working on Numbers. He has found few numbers behvae in a different way.
If a number is divisible by the sum of its individual digits then he wants to name that number has H Number
Example: Number 200 is a H Number because the sum of digits 2 and 0 and 0 is 2(2+0+0) and 200 is divisible by 2. 
Number 171 is a Harshad Number because the sum of digits 1 and 7 and 1 is 9(1+7+1) and 171 is divisible by 9.
Help Jobs to say if a given number is H number or not. If H number print Yes else print No
Sample 1:
input=200
output=Yes
Sample 2:
input=101
output=No
Sample 3:
input=-12
output=-1
Note : if a given number is negative print -1.

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
        if (num < 0) {
            System.out.println(-1);
            return;
        }
        int sum = 0;
        int n = num;
        while (n > 0) {
            sum += n % 10;
            n /= 10;
        }
        if (num % sum == 0) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }
    }
}

150th Problem
SHyam is working on String S, he was asked to develop a method to return the longest substring in S, which is a palindrome.
NOTE: Alphabets are case sensitive
THe lenght of the palindrome should be atleast 2 characters.
If no palindrome substring print -1.
input = abbbabbcbbacdb
output = abbcbba
input = aaaaa
output = aaaaa

import java.util.*;
public class Solution{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        System.out.println(longestPalindrome(s));
    }
    public static String longestPalindrome(String s) {
        if (s.isEmpty() || s.length() == 1) {
            return "-1";
        }
        String longest = "";
        for (int i = 0; i < s.length(); i++) {
            for (int j = i + 1; j < s.length(); j++) {
                String substring = s.substring(i, j + 1);
                if (isPalindrome(substring)) {
                    if (substring.length() > longest.length()) {
                        longest = substring;
                    }
                }
            }
        }
        if (longest.isEmpty()) {
            return "-1";
        }
        return longest;
    }
    public static boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}

151st Problem
Shiva is given an matrix.He has to find the  element of the matrix such that it is the smallest element in its row and greatest in its column.
The first line of input contains the size of the matrix followed by matrix elements
Input = 3 3
3 7 8
9 11 13 
15 16 17
Output = 15
Explanation: 15 is the since it is the smallest in its row and the greatest in its column
Note - Print -1 if no such element exists

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] matrix = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                matrix[i][j] = sc.nextInt();
            }
        }
        int result = -1;
        for (int i = 0; i < n; i++) {
            int minRow = matrix[i][0];
            int minCol = 0;
            for (int j = 1; j < m; j++) {
                if (matrix[i][j] < minRow) {
                    minRow = matrix[i][j];
                    minCol = j;
                }
            }
            int maxCol = matrix[0][minCol];
            for (int k = 1; k < n; k++) {
                if (matrix[k][minCol] > maxCol) {
                    maxCol = matrix[k][minCol];
                }
            }
            if (minRow == maxCol) {
                result = minRow;
                break;
            }
        }
        System.out.println(result);
    }
}

152nd Problem
Given the array of integers nums, you will choose two different indices i and j 
of that array. 
Return the maximum value of (nums[i]-1)*(nums[j]-1).
input =4
3 4 5 2
output =12 
If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum 
value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. 
input =4
1 5 4 5
output =16
Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the 
maximum value of (5-1)*(5-1) = 16.
input =2
3 7
output =12

import java.util.*;
class Solution {
  public static int maxProduct(int[] nums) {
    Arrays.sort(nums);
    int n = nums.length;
    int a = nums[n-1];
    int b = nums[n-2];
    return (a-1) * (b-1);
  }
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int[] nums = new int[n];
    for (int i = 0; i < n; i++) {
      nums[i] = sc.nextInt();
    }
    int result = maxProduct(nums);
    System.out.println(result);
  }
}

153rd Problem
Motu Patlu  are good friends, Motu loves to eat Samosas, 
He is given N Boxes of samosas[], box-'a' has samosas[a].
He can choose two boxes having highest number of samosas each time, 
box-i and box-j, where  samosas[i] <= samosas[j].
If samosas[i] == samosas[j] , then eat all the samosas from both boxes;
If samosas[i] != samosas[j] , then eat all samosas from box-i, 
and from box-j eat only samosas[i] samosas, and left with ( samosas[j]-samosas[i] ) 
If the box becomes empty, remove the box.	
At the end, there is at most 1 box left. Return the number of samosas left 
in that box (or 0 if there are no boxes left.)
Input Format:
N space separated integers, number of samosas[i] in box[i]
Output Format:
Print number of the samosas left at the end.
Sample Input-1:
2 7 4 1 8 1
Sample Output-1:
1
Explanation:
Boxes are numbered from 0,1,2,...,N-1.
Motu selects, box-1 has 7 samosas and box-4 has 8 samosas eat 14 samosas, boxes becomes [2,4,1,1,1]
Motu selects, box-0 has 2 samosas and box-1 has 4 samosas eat 4 samosas, boxes becomes [2,1,1,1]
Motu selects, box-1 has 1 samosa and box-0 has 2 samosas eat 2 samosas, boxes becomes [1,1,1]
Motu selects, box-0 has 1 samosa and box-1 has 1 samosa eat 2 samosas, boxes becomes [1]
Finally left with 1 box, box contains 1 samosa in it.

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] samosas = new int[n];
        for (int i = 0; i < n; i++) {
            samosas[i] = scanner.nextInt();
        }
        while (n > 1) {
            Arrays.sort(samosas);
            int i = n - 1;
            int j = n - 2;
            if (samosas[i] == samosas[j]) {
                samosas[i] = 0;
                samosas[j] = 0;
                n -= 2;
            } else {
                samosas[i] = 0;
                samosas[j] -= samosas[i];
                n--;
            }
        }
        int remainingSamosas = 0;
        for (int i = 0; i < samosas.length; i++) {
            remainingSamosas += samosas[i];
        }
        System.out.println(remainingSamosas);
    }
}

154th Problem
In a cricket match,a batsman can score a maxium of one or zero. 
The captain hari has been given the scores of the batsman in the match.
Captain is intrested to write all the scores of the match in an particular order.
He writes all zeros to the left and all ones to the right. 
help Captain hari to arrange them accordingly
He has been given the random scores of the batsman in a match.
Input = 10
0 1 0 1 0 0 1 1 1 0
Output = 0 0 0 0 0 1 1 1 1 1
input = 2
0 1
output = 0 1
input = 3
1 1 0
output = 0 1 1 
Note - The first line of input contains the number of players followed by player score

import java.util.*;
public class Solution {
    public static void sortArray(int[] arr, int n) {
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (arr[i] == 0) {
                count++;
            }
        }
        for (int i = 0; i < count; i++) {
            arr[i] = 0;
        }
        for (int i = count; i < n; i++) {
            arr[i] = 1;
        }
    }
    public static void printArray(int[] arr, int n) {
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        sortArray(arr, n);
        printArray(arr, n);
    }
}

155th Problem
In a Coding Hackathon, each individual is given a score,
if the scores of any 3 students meet the Target score, they will be given a prize.
Please hello the Coding Hackathon team regarding the same.
If you find any 3 students score equal to the target score, print true else false
Input - The first line of input contains the number of students participating followed by student scores followed by target score. 
input = 5
10 20 30 40 50
100
output = true
we have the scores {20,30,50} which meets the target score. 
input = 5
50 30 60 20 10
40
output = false
we dont have the scores which meets the targest score (40)

import java.util.*;
public class Solution {
    public static boolean findTriplet(int[] arr, int n, int target) {
        java.util.Arrays.sort(arr);
        for (int i = 0; i < n - 2; i++) {
            int left = i + 1;
            int right = n - 1;
            while (left < right) {
                int sum = arr[i] + arr[left] + arr[right];
                if (sum == target) {
                    return true;
                }
                else if (sum < target) {
                    left++;
                }
                else {
                    right--;
                }
            }
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        int target = sc.nextInt();
        boolean result = findTriplet(arr, n, target);
        System.out.println(result);
    }
}

156th Problem
NOTE- USE RECURSION ONLY.
DONT SIMPLY WRITE (X*Y)
Given two numbers x and y find the product using recursion.
Examples : 
Input = 5 4
Output = 20
Input = 100 20
Output =2000

import java.util.*;
public class Solution{
public static int product(int x, int y) {
  if (x < y) {
    return product(y, x);
  }
  else if (y == 0) {
    return 0;
  }
  else {
    return x + product(x, y - 1);
  }
}
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
      int x = sc.nextInt();
      int y = sc.nextInt();
      System.out.println(product(x, y));
    }
}

157th Problem
In a Military Operation, The Army Chief is given the heights of the Himalayan Mountains. 
The soldiers can attack if the heights of the mountains are in Z Fashion
(if either all values are increasing or decreasing or first increasing and then decreasing). 
Soldiers need to find whether the heights which falls in the given range has values in the form of a Z or not
if the heights in the given range  [h1, h2, h3 … hN] is said to be in form of a Z if there exist an 
integer K, 1 <= K <= N such that, 
h1 <= h2 <= h3 .. <= hK >= h(K+1) >= h(K+2) …. >= hN 
The Army Chief gives the soldiers the heights of the mountains followed by the range of the mountains 
Examples: 
Input = 2 3 2 4 4 6 3 2
0 2
Output =  true
Explanation: The output is true , Z Fashion is [2 3 2], 
heights first increases and then decreases
Input = 2 3 2 4 4 6 3 2
2 7
Output = true
Explanation: The output is true , Z fashion is [2 4 4 6 3 2], 
heights first increases and then decreases
Input = 2 3 2 4 4 6 3 2
1 3
Output = false
Explanation: The output is false, Z fashion  is [3 2 4], 
heights are  not in the form above stated

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String[] heights = sc.nextLine().split(" ");
        int start = sc.nextInt();
        int end = sc.nextInt();
        boolean isZ = false;
        for (int i = start + 1; i < end; i++) 
        {
            if (Integer.parseInt(heights[i]) > Integer.parseInt(heights[i - 1]) && Integer.parseInt(heights[i]) > Integer.parseInt(heights[i + 1])) 
            {
                isZ = true;
                break;
            } else if (Integer.parseInt(heights[i]) < Integer.parseInt(heights[i - 1]) && Integer.parseInt(heights[i]) < Integer.parseInt(heights[i + 1])) {
                isZ = true;
                break;
            }
        }
        System.out.println(isZ);
    }
}

158th Problem
T Strings. 
Shyam reads a line of statement from the English Text Book. He is very fond of the Letter 't'/'T'.
If a Word contains a Letter 't'/'T' he counts the numbers in the given word.
Help Shyam to display the sum of the numbers in the word.
if no numbers are found print 0
for example:
input = Tw1nkl3 to1 add4
output =
Tw1nkl3(4)
to1(1)
add4(0)
input = add me
output =
add(0)
me(0)

import java.util.*;
public class SumOfNumbersInWords {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String input = sc.nextLine();
        String[] words = input.split(" ");
        for (String word : words) {
            int sum = 0;
            for (char c : word.toCharArray()) {
                if (Character.isDigit(c)) {
                    sum += Character.getNumericValue(c);
                }
            }
            System.out.println(word + "(" + sum + ")");
        }
    }
}

159th Problem
Bob has given a year between 1900 to 1999 
he has to write the year into words 
Note - if any other year is given print INVALID 
Few Examples
input = 1980
output = ONE NINE EIGHT ZERO
input = 1900
output = ONE NINE ZERO ZERO 
input = 2003
output = INVALID 

import java.util.*;
public class YearToWords {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int year = sc.nextInt();
        if (year >= 1900 && year <= 1999) {
            String[] words = {"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"};
            String yearInWords = "";
            for (char c : String.valueOf(year).toCharArray()) {
                yearInWords += words[Character.getNumericValue(c)] + " ";
            }
            System.out.println(yearInWords.trim());
        } else {
            System.out.println("INVALID");
        }
    }
}

160th Problem
Mr. Robert has an portrait photo with size M*N pixels, 
where M is the length of the portrait and N is width of the portrait.
You are given an integer S in pixels,
Your task is to help Mr. Robert to find the actual values 
[M, N] using the following specifications:
	- The size of portrait should be equal to S. i.e., S = M*N.
 	- N is always smaller than in M, i.e., N <= M
 	- The diffrence between length and width, (M-N) should be minimum.
 	And print the result as a pair M and N.
NOTE: S is always a positive integer.
Input Format:
Line-1 -> An integer S, size of the portrait.
Output Format:
Print the result as a pair of integers.
Sample Input-1:
24
Sample Output-1:
6 4
Sample Input-2:
550
Sample Output-2:
25 22

import java.util.*;
public class Solution{
  public static void findFactors (int S) {
    int M = 0;
    int N = 0;
    for (int i = (int) Math.sqrt (S); i >= 1; i--) {
      if (S % i == 0) {
        N = i;
        M = S / i;
        break;
      }
    }
    System.out.println (M + " " + N);
  }
  public static void main (String[] args) {
    Scanner sc = new Scanner (System.in);
    int S = sc.nextInt ();
    findFactors (S);
  }
}

161st Problem
Write a program to implement knapsack problem using Bruteforce approach.
Input Format :
Line 1 : N space separated numbers, weigths[]
Line 2 : N space separated numbers, values[]
Line 3 : A number, capacity
Output Format : 
Line 1 : Number, maximum profit / 0 for boundary conditions
Sample Input 1 :
5 3 4
20 40 30
10
Sample Output 1 :
70
Sample Input 2 :
5 3 4
20 40 30
0
Sample Output 2 :
0

import java.util.*;
public class Solution {
  public static int findMaxProfit(int[] weights, int[] values, int capacity) {
    int maxProfit = 0;
    int n = weights.length;
    for (int i = 0; i < (1 << n); i++) {
      int currentWeight = 0;
      int currentProfit = 0;
      for (int j = 0; j < n; j++) {
        if ((i & (1 << j)) != 0) {
          currentWeight += weights[j];
          currentProfit += values[j];
        }
      }
      if (currentWeight <= capacity && currentProfit > maxProfit) {
        maxProfit = currentProfit;
      }
    }
    return maxProfit;
  }
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int[] weights = readArray(sc);
    int[] values = readArray(sc);
    int capacity = sc.nextInt();
    int maxProfit = findMaxProfit(weights, values, capacity);
    System.out.println("The maximum profit is: " + maxProfit);
  }
  public static int[] readArray(Scanner sc) {
    String line = sc.nextLine();
    String[] parts = line.split(" ");
    int[] array = new int[parts.length];
    for (int i = 0; i < parts.length; i++) {
      array[i] = Integer.parseInt(parts[i]);
    }
    return array;
  }
}

162nd Problem
Write a program to perform string matching a.k.a pattern matching.
Input Format :
Line 1 : A string for main string
Line 2 : A string for pattern
Output Format :
Line 1 : A number, index(if pattern found return first occurance) or -1(element not found)
Sample Input 1 :
hello
ll
Sample Output 1 :
2
Sample Input 2 :
123456789
567
Sample Output 2 :
4
Sample Input 3 :
helloworld
xyz
Sample Output  :
-1

import java.util.*;
public class Solution{
  public static int stringMatch (String main, String pattern) {
    return main.indexOf (pattern);
  }
  public static void main (String[] args) {
    Scanner sc = new Scanner (System.in);
    String main = sc.nextLine ();
        String pattern = sc.nextLine ();
    int result = stringMatch (main, pattern);
    System.out.println (result);
  }
}

163rd Problem
You are Given an array of length of n , find the majority element.
The majority element is the element that appears more than [n / 2] times.
You may assume that the majority element always exists in the array.
Note: Solve it using divide and conquer technique
Input Format :
Line-1 : N space separated numbers, list[]
Output Format :
Line-1 : A number, largest element in array
Sample Input :
1 2 4 5 1 1 1
Sample Output :
1
Sample Input :
6 2 6
Sample Output :
6

import java.util.*;
public class Solution {
  public static int findMajorityElement(int[] arr, int low, int high) {
    if (low == high) {
      return arr[low];
    }
    int mid = low + (high - low) / 2;
    int leftMajority = findMajorityElement(arr, low, mid);
    int rightMajority = findMajorityElement(arr, mid + 1, high);
    if (leftMajority == rightMajority) {
      return leftMajority;
    }
    int leftCount = countFrequency(arr, low, high, leftMajority);
    int rightCount = countFrequency(arr, low, high, rightMajority);
    if (leftCount > rightCount) {
      return leftMajority;
    } else if (rightCount > leftCount) {
      return rightMajority;
    } else {
      return -1;
    }
  }
  public static int countFrequency(int[] arr, int low, int high, int element) {
    int frequency = 0;
    for (int i = low; i <= high; i++) {
      if (arr[i] == element) {
        frequency++;
      }
    }
    return frequency;
  }
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int[] arr = readArray(sc);
    int result = findMajorityElement(arr, 0, arr.length - 1);
    System.out.println(result);
  }
  public static int[] readArray(Scanner sc) {
    String line = sc.nextLine();
    String[] parts = line.split(" ");
    int[] array = new int[parts.length];
    for (int i = 0; i < parts.length; i++) {
      array[i] = Integer.parseInt(parts[i]);
    }
    return array;
  }
}

164th Problem
You are given a 0-indexed array of distinct integers nums.
There is an element in nums that has the lowest value and an element that has the highest value. 
We call them the minimum and maximum respectively. 
Your goal is to remove both these elements from the array.
A deletion is defined as either removing an element from the front of the array 
or removing an element from the back of the array.
Return the minimum number of deletions it would take to remove both the minimum and maximum element from the array.
Input Format:
Line 1: A number
Line 2: Array elements
Output Format:
Line 1: A number
Sample Input 1:
8
2 10 7 5 4 1 8 6
Sample Output 1:
5
Explanation: 
The minimum element in the array is nums[5], which is 1.
The maximum element in the array is nums[1], which is 10.
We can remove both the minimum and maximum by removing 2 elements from the front and 3 elements from the back.
This results in 2 + 3 = 5 deletions, which is the minimum number possible.
Sample Input 2:
8
0 -4 19 1 8 -2 -3 5
Sample Output 2:
3
Explanation: 
The minimum element in the array is nums[1], which is -4.
The maximum element in the array is nums[2], which is 19.
We can remove both the minimum and maximum by removing 3 elements from the front.
This results in only 3 deletions, which is the minimum number possible.
Sample Input 3:
1
100
Sample Output 3:
1
Explanation:  
There is only one element in the array, which makes it both the minimum and maximum element.
We can remove it with 1 deletion.

import java.util.*;
public class Solution {
  public static int findMinDeletions(int[] arr) {
    int minIndex = 0;
    int maxIndex = 0;
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] < arr[minIndex]) {
        minIndex = i;
      }
      if (arr[i] > arr[maxIndex]) {
        maxIndex = i;
      }
    }
    if ((minIndex == 0 && maxIndex == arr.length - 1) || (minIndex == arr.length - 1 && maxIndex == 0)) {
      return 2;
    }
    if (minIndex == 0 || minIndex == arr.length - 1 || maxIndex == 0 || maxIndex == arr.length - 1) {
      return 1;
    }
    return 2 + Math.min(minIndex, maxIndex) + Math.min(arr.length - 1 - minIndex, arr.length - 1 - maxIndex);
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
        int size = sc.nextInt();
    int[] arr = new int[size];
       for (int i = 0; i < size; i++) {
      arr[i] = sc.nextInt();
    }
    int result = findMinDeletions(arr);
    System.out.println(result);
  }
}

165th Problem
You are given a positive integer num consisting only of digits 6 and 9.
Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).
input =9669
output =9969
Explanation: 
Changing the first digit results in 6669.
Changing the second digit results in 9969.
Changing the third digit results in 9699.
Changing the fourth digit results in 9666.
The maximum number is 9969.
input =9996
output =9999
Explanation: Changing the last digit 6 to 9 results in the maximum number.
input =9999
output =9999
Explanation: It is better not to apply any change.

import java.util.Scanner;
public class Solution {
  public static int findMaxNumber(int num) {
    String str = String.valueOf(num);
    StringBuilder sb = new StringBuilder();
    boolean changed = false;
    for (char ch : str.toCharArray()) {
      if (ch == '6' && !changed) {
        sb.append('9');
        changed = true;
      } else {
        sb.append(ch);
      }
    }
    return Integer.parseInt(sb.toString());
  }
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int num = sc.nextInt();
    int result = findMaxNumber(num);
    System.out.println(result);
  }
}

166th Problem
Given an array of strings words and a string s, determine if s is an acronym of words.
The string s is considered an acronym of words if it can be formed by concatenating the first character of each string in words in order. 
For example, "ab" can be formed from ["apple", "banana"], but it can't be formed from ["bear", "aardvark"].
Return true if s is an acronym of words, and false otherwise.
input =alice bob charlie
abc
output =true
Explanation: The first character in the words "alice", "bob", and "charlie" are 'a', 'b', and 'c', respectively. Hence, s = "abc" is the acronym. 
input =an apple
a
output =false
Explanation: The first character in the words "an" and "apple" are 'a' and 'a', respectively. 
The acronym formed by concatenating these characters is "aa". 
Hence, s = "a" is not the acronym.
input =never gonna give up on you
ngguoy
output =true
Explanation: By concatenating the first character of the words in the array, we get the string "ngguoy". 
Hence, s = "ngguoy" is the acronym.

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] words = scanner.nextLine().split(" ");
        String s = scanner.nextLine();
        boolean isAcronym = true;
        for (int i = 0; i < s.length(); i++) {
            if (i >= words.length || s.charAt(i) != words[i].charAt(0)) {
                isAcronym = false;
                break;
            }
        }
        System.out.println(isAcronym);
    }
}

167th Problem
Given a string s, return true if a permutation of the string could form a palindrome and false otherwise.
input =code
output =false
input =aab
output =true
input =carerac
output =true

import java.util.*;
public class Solution {
  public static boolean canFormPalindrome(String s) {
    HashMap<Character, Integer> map = new HashMap<>();
    for (char c : s.toCharArray()) {
      if (map.containsKey(c)) {
        map.put(c, map.get(c) + 1);
      } else {
        map.put(c, 1);
      }
    }
    int oddCount = 0;
    for (int value : map.values()) {
      if (value % 2 != 0) {
        oddCount++;
      }
      if (oddCount > 1) {
        return false;
      }
    }
    return true;
  }
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    boolean result = canFormPalindrome(s);
    System.out.println(result);
  }
}

168th Problem
Assume you are an awesome parent and want to give your children some cookies. 
But, you should give each child at most one cookie.
Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; 
and each cookie j has a size s[j]. 
If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. 
Your goal is to maximize the number of your content children and print the maximum number.
Example:
Input: g = [1,2,3], s = [1,1]
Output: 1
Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
Input Format :
Line 1 : An array of N elements, greed factors
Line 2 : An array of N elements, size of each cookie
Output Format :
Line 1 : A number, the maximum cookie allocation.
Sample Input 1 :
1 2 3
1 1
Sample Output 1 :
1
Sample Input 2 :
1 2
1 2 3
Sample Output 2 :
2
Sample Input 3 :
7 8 9 10
5 6 7 8
Sample Output 3 :
2

import java.util.*;
public class Solution {
    public static int findMaxContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int i = 0;
        int j = 0;
        int count = 0;
        while (i < g.length && j < s.length) {
            if (s[j] >= g[i]) {
                count++;
                i++;
                j++;
            } else {
                j++;
            }
        }
        return count;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in); 
        String[] gStr = sc.nextLine().split(" "); 
        String[] sStr = sc.nextLine().split(" ");
        int[] g = new int[gStr.length]; 
        int[] s = new int[sStr.length]; 
        for (int k = 0; k < gStr.length; k++) {
            g[k] = Integer.parseInt(gStr[k]);
        }
        for (int k = 0; k < sStr.length; k++) {
            s[k] = Integer.parseInt(sStr[k]);
        }
        System.out.println(findMaxContentChildren(g, s));
    }
}

169th Problem
Given an integer array nums, find the contiguous subarray (containing at least one number) 
which has the largest sum and return its sum.
A subarray is a contiguous part of an array.
Sample Input 1:
-2 1 -3 4 -1 2 1 -5 4
Sample Output 1:
6
Explanation: [4,-1,2,1] has the largest sum = 6.
Sample Input 2:
1 2 3 4 5
Sample Output 2:
15

import java.util.*;
class Solution {
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        String s=sc.nextLine();
        String str[]=s.split(" ");
        int arr[]=new int[str.length];
        for(int i=0;i<str.length;i++)
        {
            arr[i]=Integer.parseInt(str[i]);
        }
        int sum=0;
        int maxsum=0;
        for(int i=0;i<arr.length;i++)
        {
            sum=Math.max(arr[i],sum+arr[i]);
            maxsum=Math.max(sum,maxsum);
        }
        System.out.println(maxsum);
    }
}

170th Problem
Given an group of numbers check if the target sum can be achieved by adding the given elements of the array in 
order to achieve the target sum.
Note : You can use any number element of the array any number of times
Print true if it possible else false
The first line of input contains the size of array followed by array elements followed by target sum
INPUT
5
3 7 0 9 1
15
OUTPUT 
true
Explanation-
=> arr[1] + arr[1] + arr[4]
=>   7    +   7    +   1
=> 15
OR
=> arr[0] + arr[0] + arr[0] + arr[0] + arr[0]
=>   3    +   3    +   3    +   3    +   3
=> 15
Although there are more possibilities for this target sum problem, 
we will print true based on the above situation.

import java.util.*;
class Solution {
    public static boolean sum(int len,int arr[],int target) {
        int rem;
        for(int i=0;i<len;i++) {
            try {
                rem=target%arr[i];
                if(rem==0)
                {
                    return true;
                }
                else
                {
                    for(int j=0;j<len;j++)
                    {
                        if(rem%arr[j]==0)
                        {
                            return true;
                        }
                    }
                }
            }
            catch(Exception e)
            {
                return false;
            }
        }
        return false;
    }
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[]=new int[n];
        for(int i=0;i<n;i++)
        {
            arr[i]=sc.nextInt();
        }
        int sum=sc.nextInt();
        System.out.println(sum(n,arr,sum));
    }
}

171st Problem
# 0 to n prime numbers
## Problem Statement
Print all Prime numbers between 1 to <n>
### Input Format
*Line #1*: An **integer** <n>        { $-10^4 < n < 10^7$ }
### Output Format
For each test case, print the **prime numbers**<number> separated by space in between, 
from **0** to given number **n**
input = 100
output = 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97

import java.util.*;
class Solution {
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        System.out.print("2 ");
        for(int i=3;i<=n;i=i+2)
        {
            boolean prime=true;
            for(int j=3;j*j<=i;j=j+2)
            {
                if(i%j==0)
                {
                    prime=false;
                    break;
                }
            }
            if(prime)
            {
                System.out.print(i+" ");
            }
        }
    }
}

172nd Problem
You are provided with a string composed of binary digits, and 
your task is to write a method that calculates the count of set bits within it. 
Input Format:
A string, consists of 0's and 1's.
Output Format:
Print an integer result.
Sample Input:
01001100001111101101010101111000
Sample Output:
17
Sample Input:
11110010111011011011011111100110
Sample Output:
22

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String binaryString = sc.nextLine();
        int count = 0;
        for (int i = 0; i < binaryString.length(); i++) {
            if (binaryString.charAt(i) == '1') {
                count++;
            }
        }
        System.out.println(count);
    }
}

173rd Problem
Vishal has given a task to find the successor of a given alphabet 'alp' 
in a given string str[]. The alphabets in the given string str[] are 
all lowercase letters and always in non-decreasing order.
A successor of 'alp' is the next smallest alphabet exist in the string str[],
which is greater than 'alp'. Assume that alphabets can be considered in 
cyclic fashion. For example: Successor for alp='z' in str[]="bcd" is 'b'.
Help Vishal to return the answer.
Can you solve it in O(log(n)) complexity?
Input Format:
Line-1:A string str[]
Line-2: a character represents an alphabet.
Output Format:
Print a character which is the successor.
Constraints:
 2 <= str.length<= 10^4
'alp' is a lowercase letter. 
Sample Input-1:
adghijl
f 
Sample Output-1:
g
Sample Input-2:
abcdefghi
j
Sample Output-2:
a

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        char alp = sc.next().charAt(0);
        int low = 0, high = str.length() - 1;
        char ans = ' ';
        while (low <= high) {
            int mid = (low + high) / 2;
            if (str.charAt(mid) == alp) {
                if (mid == str.length() - 1) {
                    ans = str.charAt(0);
                } else {
                    ans = str.charAt(mid + 1);
                }
                break;
            } else if (str.charAt(mid) < alp) {
                low = mid + 1;
            } else {
                ans = str.charAt(mid);
                high = mid - 1;
            }
        }
        System.out.println(ans);
    }
}

174th Problem
Write a Java program to input N and display Nth Fibonacci number.
case=1
input=1
output=1
case=2
input=8
output=21
case=3
input=5
output=5

import java.util.*;
class dpFib {
    public static int fib(int n) {
        int arr[]=new int[n+1];
        arr[0]=0;
        arr[1]=1;
        if(n<=1) {
            return arr[n];
        }
        else {
            for(int i=2;i<=n;i++) {
                arr[i]=arr[i-1]+arr[i-2];
            }
        }
        return arr[n];
    }
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        System.out.println(fib(n));
    }
}

175th Problem
Write Java program to find factorial using Dynamic Programing
case=1
input=5
output=120
case=2
input=3
output=6 

import java.util.*;
class dpFact {
    public static int fact(int n) {
        int arr[]=new int[n+1];
        arr[0]=1;
        arr[1]=1;
        if(n<=1) {
            return arr[n];
        }
        else {
            arr[n]=n*fact(n-1);
        }
        return arr[n];
    }
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        System.out.println(fact(n));
    }
}

176th Problem
/* Mr.Balu is playing with  binary trees, he has a small puzzle in that play. 
The puzzle is as follows, he has to find total number of nodes which are greater 
than all the nodes with in the path from root to that node.(include root also)
You will be given root node of a binary tree return total number of nodes which 
satiesfies above statement.
Input format: space seperated integers
output format: an integer
Example 1:
input=3 1 4 3 -1 1 5
output=4
Example 2:
input= 3 5 1 6 2 9 8 -1 -1 7 4
output=6. */

import java.util.*;
class BinaryTreeNode {
    public Integer data;
    public BinaryTreeNode left, right;
	public BinaryTreeNode(Integer data) {
        this.data = data;
        this.left = this.right = null;
    }
}
class Solution {
    public int largerNodes(BinaryTreeNode root) 
    {
        //  WRITE YOUR CODE HERE
        int count[]=new int[1];
        largerNodes(root,count,Integer.MIN_VALUE);
        return count[0];
    }
    private void largerNodes(BinaryTreeNode root, int[] count, int max)
    {
        //  WRITE YOUR CODE HERE
        if(root==null)
        {
            return;
        }
        if(root.data>max)
        {
            count[0]++;
            max=root.data;
        }
        largerNodes(root.left,count,max);
        largerNodes(root.right,count,max);
    }
}
class CountLargerNodes {
    static BinaryTreeNode root;
    void insert(BinaryTreeNode temp, Integer key) {
        if (temp == null) {
            root = new BinaryTreeNode(key);
            return;
        }
		Queue<BinaryTreeNode> q = new LinkedList<>();
        q.add(temp);
        // Do level order traversal until we find an empty place.
        while (!q.isEmpty()) {
            temp = q.remove();
            if (temp.left == null) {
				if (key != null ) {
                    temp.left = new BinaryTreeNode(key);
                }
                break;
            } else {
                q.add(temp.left);
            }
            if (temp.right == null) {
				if (key != null) {
                    temp.right = new BinaryTreeNode(key);
                }
                break;
            } else {
                q.add(temp.right);
            }
        }
    }
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String[] str = sc.nextLine().split(" ");
        CountLargerNodes st = new CountLargerNodes();
        BinaryTreeNode root1 = new BinaryTreeNode(Integer.parseInt(str[0]));
        for (int i = 1; i < str.length; i++) 
            st.insert(root1, Integer.parseInt(str[i]));
        Solution sol = new Solution();
        System.out.println(sol.largerNodes(root1));
    }
}

177th Problem
/* Sharath is playing a game where there are N levels. Inorder to win the game 
he has to reach Nth level. The rule book explains "In one step you can either cross one level or two levels".
Return the number of distinct possible ways to win the game.
Constraints:
    1 <= N <= 45
Input Format:
Line-1: An Integer N represents number of levels.
Output Format:
Print an integer.
Sample Input-1:
2 
Sample Output-1:
2
Explanation:
1. 1-level+ 1-level =2
2. 2 levels in one step.   
Sample Input-2:
4  
Sample Output-2:
5
Explanation:
1. 1-level + 1-level + 1-level + 1-level = 4
2. 1-level + 1-level + 2-levels = 4
3. 1-level + 2-levels + 1-level = 4
4. 2-levels + 1-level + 1-level = 4
5. 2-levels + 2-levels  = 4 */

import java.util.*;
class ClimbingStairs {
 public static int stairs(int n){
     int arr[] = new int[n+1];
     arr[0]=1;
     arr[1]=1;
     if(n<=1){
         return arr[n];
     } else 
     {
         for(int i=2;i<=n;i++)
         {
         arr[i] = arr[i-1]+arr[i-2];
         }
     }
     return arr[n];
 }   
 public static void main(String args[]){
     Scanner sc = new Scanner(System.in);
     int n = sc.nextInt();
     System.out.println(stairs(n));
    }
}

178th Problem
Shyam is a given a series of numbers. 
The series of numbers follow each one of the following character sequence. 
I/E/D
I-Increase
D-Decrease
E-Equal
For example for the input 
input = 5123445
output = IDIIIEI
Note- The first Digit is always I 
After the digit 5 we have 1 which is Decreasing, followed by 1 we have 2 which is Increasing
Follow the same pattern for the next digits.
In the above example after 3 we have 4 which is Increasing, following 4 we have 4 which is Equal. 
SO we have E there. 
input = 6333
output = IDEE
Help Shyam to print the sequce for all the numbers

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        String numbers = input.next();
        String sequence = getSequence(numbers);
        System.out.println(sequence);
    }
    public static String getSequence(String numbers) {
        StringBuilder sequence = new StringBuilder("I");
        for (int i = 1; i < numbers.length(); i++) {
            if (numbers.charAt(i) > numbers.charAt(i - 1)) {
                sequence.append("I");
            } else if (numbers.charAt(i) < numbers.charAt(i - 1)) {
                sequence.append("D");
            } else {
                sequence.append("E");
            }
        }
        return sequence.toString();
    }
}

179th Problem
Manoj is working on the Invoice Billing System.
He is able to do the Billing as per the goods ordered by the customers.
The customer requested the Manoj to print the Amount in the Invoice in words. 
Help Manoj to solve the problem 
Note - The input number is between 0 to 9999
input = 567
output = Five Hundred Sixty Seven
input = 9999
output = Nine Thousand Nine Hundred Ninty Nine
input = 2000
output = Two Thousand

import java.util.Scanner;
public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int number = input.nextInt();
        String result = numberToWords(number);
        System.out.println(result);
    }
    public static String numberToWords(int num) {
        if (num == 0) {
            return "Zero";
        }
        String[] lessThan20 = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten",
                "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
        String[] tens = {"", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
        String[] thousands = {"", "Thousand", "Million", "Billion"};
        int i = 0;
        String words = "";
        while (num > 0) {
            if (num % 1000 != 0) {
                words = helper(num % 1000, lessThan20, tens) + thousands[i] + " " + words;
            }
            num /= 1000;
            i++;
        }
        return words.trim();
    }
    public static String helper(int num, String[] lessThan20, String[] tens) {
        if (num == 0) {
            return "";
        } else if (num < 20) {
            return lessThan20[num] + " ";
        } else if (num < 100) {
            return tens[num / 10] + " " + helper(num % 10, lessThan20, tens);
        } else {
            return lessThan20[num / 100] + " Hundred " + helper(num % 100, lessThan20, tens);
        }
    }
}

180th Problem
Vishal has given a task to find the successor of a given alphabet 'alp' in a given string str[].
The alphabets in the given string str[] are all lowercase letters and always in non-decreasing order.
A successor of 'alp' is the next smallest alphabet exist in the string str[] which is greater than 'alp'.
Assume that alphabets can be considered in cyclic fashion.
For example: Successor for alp='z' in str[]="bcd" is 'b'.
Input Format:
Line-1:A string str[]
Line-2: a character represents an alphabet.
Output Format:
Print a character which is the successor. 
Sample Input-1:
adghijl
f 
Sample Output-1:
g
Sample Input-2:
abcdefghi
j
Sample Output-2:
a

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        String str = input.next();
        char alp = input.next().charAt(0);
        char successor = findSuccessor(str, alp);
        System.out.println(successor);
    }

    public static char findSuccessor(String str, char alp) {
        for (char c : str.toCharArray()) {
            if (c > alp) {
                return c;
            }
        }
        return str.charAt(0);
    }
}

181st Problem
We define a harmonious array as an array where the difference between its maximum value and its minimum
value is exactly 1 .
Given an integer array nums , return the length of its longest harmonious subsequence among all its possible
subsequences.
A subsequence of array is a sequence that can be derived from the array by deleting some or no elements
without changing the order of the remaining elements.
Input Format:
Line-1:A space seperated numbers, arr[]
Output Format:
A number 
Sample Input-1:
1 3 2 2 5 2 3 7 
Sample Output-1:
5
Explanation:
The longest harmonious subsequence is [3,2,2,2,3].
Sample Input-2:
1 2 3 4
Sample Output-2:
2

import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        String[] arr = input.nextLine().split(" ");
        int[] nums = Arrays.stream(arr).mapToInt(Integer::parseInt).toArray();
        int result = findLHS(nums);
        System.out.println(result);
        input.close();
    }
    public static int findLHS(int[] nums) {
        Map<Integer, Integer> counts = new HashMap<>();
        for (int num : nums) {
            counts.put(num, counts.getOrDefault(num, 0) + 1);
        }
        int result = 0;
        for (int num : counts.keySet()) {
            if (counts.containsKey(num + 1)) {
                result = Math.max(result, counts.get(num) + counts.get(num + 1));
            }
        }
        return result;
    }
}

182nd Problem
Given a 0-indexed integer array nums, 
return the smallest index i of nums such that i mod 10 == nums[i], 
or -1 if such index does not exist.
Input Format:
Line-1:Space separeted numbers
Output Format:
Print a number, index or -1
Sample Input-1:
4 3 2 1
Sample Output-1:
2
Sample Input-2:
1 2 3 4 5 6 7 8 9
Sample Output-2:
-1

import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] input = scanner.nextLine().split(" ");
        int[] nums = new int[input.length];
        for (int i = 0; i < input.length; i++) {
            nums[i] = Integer.parseInt(input[i]);
        }
        int result = -1;
        for (int i = 0; i < nums.length; i++) {
            if (i % 10 == nums[i]) {
                result = i;
                break;
            }
        }
        System.out.println(result);
    }
}

183rd Problem
You have n coins and you want to build a staircase with these coins. 
The staircase consists of k rows where the i row has exactly i coins. 
The last row of the staircase may be incomplete.
Given the integer n , return the number of complete rows of the staircase you will build.
Input Format:
A number
Output Format:
A number
Sample Input-1:
5
Sample Output-1:
2
Sample Input-2:
8
Sample Output-2:
3

import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int rows = (int) (Math.sqrt(2 * (long) n + 0.25) - 0.5);
        System.out.println(rows);
    }
}

184th Problem
Nagesh has given two words to check whether the first word 'source' is a sub-series of second word 'target'.
A sub-series from a word can be formed by removing 0 or more characters without changing the relative order of other characters in the word.
For example, 'nest' is a subseries of a word 'interst' , where as 'rest' is not.
Help Nagesh to return true if source is a subseries of target, otherwise false.
Input Format:
Line-1:Two space separeted strings
Output Format:
Print a boolean result.
Sample Input-1:
pqsv pqrstuv
Sample Output-1:
true
Sample Input-2:
psr pqrst
Sample Output-2:
false

import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String source = scanner.next();
        String target = scanner.next();
        boolean result = isSubSeries(source, target);
        System.out.println(result);
    }
    public static boolean isSubSeries(String source, String target) {
        int i = 0;
        for (int j = 0; j < target.length() && i < source.length(); j++) {
            if (source.charAt(i) == target.charAt(j)) {
                i++;
            }
        }
        return i == source.length();
    }
}

185th Problem
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Example 1:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:
Input: nums = [3,2,4], target = 6
Output: [1,2]

public class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[] { i, j };
                }
            }
        }
    throw new IllegalArgumentException("No two sum solution");
    }
}

186th Problem
Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.
Example 1:
Input: s = "leetcode"
Output: 0
Example 2:
Input: s = "loveleetcode"
Output: 2
Example 3:
Input: s = "aabb"
Output:-1

public class Solution {
    public int firstUniqChar(String s) {
        int[] charCount = new int[26];
        for (char c : s.toCharArray()) {
            charCount[c - 'a']++;
        }
        for (int i = 0; i < s.length(); i++) {
            if (charCount[s.charAt(i) - 'a'] == 1) {
                return i;
            }
        }
        return -1;
    }
}

187th Problem
Given an integer x, return true if x is a palindrome, and false otherwise.

public class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0) {
            return false;
        }
        int reversed = 0;
        int original = x;
        while (x != 0) {
            int digit = x % 10;
            reversed = reversed * 10 + digit;
            x /= 10;
        }
        return original == reversed;
    }
}

188th Problem
/* Given r red, b blue, and g green balls, find the total number of arrangements
in a row such that no two balls of the same color end up together.
input format : three integers (first integer is for r second is b and last is for g)
output format : integer number
Input:1  2 1
Output:6
The arrangements are [bgbr, bgrb, brbg, brgb, gbrb, rbgb]
Input:  2 3 1
Output:10
The arrangements are [bgbrbr, bgrbrb, brbgbr, brbgrb, brbrbg, brbrgb, 
brgbrb, gbrbrb, rbgbrb, rbrbgb] */

import java.util.*;
public class Arrangement {
    public static int f(int r, ixnt b, int g, char j, HashMap<String, Integer> memo) {
        String key = r + "" + b + "" + g + "*" + j;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }
        if (r < 0 || b < 0 || g < 0) return 0;
        if (r == 0 && g == 0 && b == 0) return 1;
        int ways = 0;
        if (j == 'r') ways = f(r, b - 1, g, 'b', memo) + f(r, b, g - 1, 'g', memo);
        else if (j == 'b') ways = f(r - 1, b, g, 'r', memo) + f(r, b, g - 1, 'g', memo);
        else if (j == 'g') ways = f(r - 1, b, g, 'r', memo) + f(r, b - 1, g, 'b', memo);
        memo.put(key, ways);
        return ways;
    }
    public static int run(int r, int b, int g) {
        HashMap<String, Integer> memo = new HashMap<>();
        return f(r - 1, b, g, 'r', memo) + f(r, b - 1, g, 'b', memo) + f(r, b, g - 1, 'g', memo);
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int r = sc.nextInt();
        int b = sc.nextInt();
        int g = sc.nextInt();
        System.out.print(run(r, b, g));
    }
}

189th Problem
The diagonal from the top left corner to the bottom right corner of a the grid 
is called the main diagonals.
You have given a m*n grid of boxes, each box is filled with an number.
Your task is to check whether, each of the main diagonal all the boxes 
are filled with same number or not. If filled with same, print true, Otherwise false.
Input Format:
Line-1: Two integers M and N, size of the grid..
Next M lines: N space separated integers, numbers filled in thr grid of boxes.
Output Format:
Print a boolean value.
Sample Input-1:
3 4
1 2 3 4
5 1 2 3 
9 5 1 2
Sample Output-1:
true
Explanation:
In the above grid, the diagonals are:
[9], [5, 5], [1, 1, 1], [2, 2, 2], [3, 3], [4].
In each diagonal all the boxes are filled with the same number, 
so the answer is True.

import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt();
        int n = scanner.nextInt();
        int[][] grid = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = scanner.nextInt();
            }
        }
        boolean result = true;
        for (int i = 1; i < Math.min(m, n); i++) {
            if (grid[i][i] != grid[0][0]) {
                result = false;
                break;
            }
        }
        System.out.println(result);
    }
}

190th Problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:
I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer.
Example 1:
Input: s = "III"
Output: 3
Explanation: III = 3.

import java.util.*;
class Solution {
    public int romanToInt(String s) {
        Map<Character, Integer> values = new HashMap<>();
        values.put('I', 1);
        values.put('V', 5);
        values.put('X', 10);
        values.put('L', 50);
        values.put('C', 100);
        values.put('D', 500);
        values.put('M', 1000);
        int result = 0;
        for (int i = 0; i < s.length(); i++) {
            if (i < s.length() - 1 && values.get(s.charAt(i)) < values.get(s.charAt(i + 1))) {
                result -= values.get(s.charAt(i));
            } else {
                result += values.get(s.charAt(i));
            }
        }
        return result;
    }
}

191st Problem
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.
Example 1:
Input: s = "()"
Output: true
Example 2:
Input: s = "()[]{}"
Output: true
Example 3:
Input: s = "(]"
Output: false

import java.util.*;
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else if (c == ')' && !stack.isEmpty() && stack.peek() == '(') {
                stack.pop();
            } else if (c == '}' && !stack.isEmpty() && stack.peek() == '{') {
                stack.pop();
            } else if (c == ']' && !stack.isEmpty() && stack.peek() == '[') {
                stack.pop();
            } else {
                return false;
            }
        }
        return stack.isEmpty();
    }
}

192nd Problem
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [1,3,5,6], target = 5
Output: 2
Example 2:
Input: nums = [1,3,5,6], target = 2
Output: 1
Example 3:
Input: nums = [1,3,5,6], target = 7
Output: 4

class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
}

193rd Problem
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = "sadbutsad", needle = "sad"
Output: 0
Explanation: "sad" occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.

public class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) {
            return 0;
        }
        for (int i = 0; i <= haystack.length() - needle.length(); i++) {
            int j;
            for (j = 0; j < needle.length(); j++) {
                if (haystack.charAt(i + j) != needle.charAt(j)) {
                    break;
                }
            }
            if (j == needle.length()) {
                return i;
            }
        }
        return -1;
    }
}

194th Problem
Given a string s consisting of words and spaces, return the length of the last word in the string.
A word is a maximal substring onsisting of non-space characters only.
Input: s = "Hello World"
Output: 5
Explanation: The last word is "World" with length 5.

class Solution {
        public int lengthOfLastWord(String s) {
    if (s == null) {
        return 0;
    }
    s = s.trim();
    int len = 0;
    for (int i = s.length() - 1; i >= 0; i--) {
        if (s.charAt(i) == ' ') {
            break;
        }
        len++;
    }
    return len;
  }
}

195th Problem
You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.
Increment the large integer by one and return the resulting array of digits.
Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].

class Solution {
public int[] plusOne(int[] digits) {
    int n = digits.length;
    for (int i = n - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i]++;
            return digits;
        }
        digits[i] = 0;
    }
    int[] newNumber = new int[n + 1];
    newNumber[0] = 1;
    return newNumber;
  }
}

196th Problem
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.
Example 1:
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.

class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        System.arraycopy(nums2, 0, nums1, 0, j + 1);
    }
}

197th Problem
Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.
You must not use any built-in exponent function or operator.
For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.
Example 1:
Input: x = 4
Output: 2
Explanation: The square root of 4 is 2, so we return 2.
Example 2:
Input: x = 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.

class Solution{
    public int mySqrt(int x) {
    if (x == 0 || x == 1) {
        return x;
    }
    long start = 1, end = x, ans = 0;
    while (start <= end) {
        long mid = (start + end) / 2;
        if (mid * mid == x) {
            return (int)mid;
        }
        if (mid * mid < x) {
            start = mid + 1;
            ans = mid;
        } else {
            end = mid - 1;
        }
    }
    return (int)ans;
}
}

198th Problem
Given a string s, return the longest palindromic substring in s.
Example 1:
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
Example 2:
Input: s = "cbbd"
Output: "bb"

class Solution{
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) return "";
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }
    public int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
}

199th Problem
Given a string s, return the number of palindromic substrings in it.
A string is a palindrome when it reads the same backward as forward.
A substring is a contiguous sequence of characters within the string.
Example 1:
Input: s = "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".
Example 2:
Input: s = "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".

public class Solution {
    public int countSubstrings(String s) {
        int count = 0;
        int n = s.length();
        for (int i = 0; i < n; i++) {
            // For odd length palindromes
            count += expandAroundCenter(s, i, i);
            // For even length palindromes
            count += expandAroundCenter(s, i, i + 1);
        }
        return count;
    }
    private int expandAroundCenter(String s, int left, int right) {
        int count = 0;
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            count++;
            left--;
            right++;
        }
        return count;
    }
}

200th Problem
Given two binary strings a and b, return their sum as a binary string.
Example 1:
Input: a = "11", b = "1"
Output: "100"
Example 2:
Input: a = "1010", b = "1011"
Output: "10101"

public class Solution {
    public String addBinary(String a, String b) {
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0; 
        StringBuilder result = new StringBuilder(); 
        while (i >= 0 || j >= 0 || carry > 0) {
            int digitA = (i >= 0) ? a.charAt(i) - '0' : 0;
            int digitB = (j >= 0) ? b.charAt(j) - '0' : 0;
            int sum = digitA + digitB + carry;
            result.insert(0, sum % 2); 
            carry = sum / 2;
            i--;
            j--;
        }
        return result.toString();
    }
}

201st Problem
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123
Output: 321
Example 2:
Input: x = -123
Output: -321

class Solution {
public int reverse(int x) {
    int reversed = 0;
    while (x != 0) {
        int digit = x % 10;
        x /= 10;
        if (reversed > Integer.MAX_VALUE / 10 || (reversed == Integer.MAX_VALUE / 10 && digit > 7)) {
            return 0;
        }
        if (reversed < Integer.MIN_VALUE / 10 || (reversed == Integer.MIN_VALUE / 10 && digit < -8)) {
            return 0;
        }
        reversed = reversed * 10 + digit;
    }
    return reversed;
    }
}

202nd Problem
Given a string s, find the length of the longest 
substring without repeating characters.
Example 1:
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Example 2:
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

class Solution {
public int lengthOfLongestSubstring(String s) {
    int n = s.length();
    int ans = 0;
    for (int i = 0; i < n; i++) {
        boolean[] visited = new boolean[128]; 
        for (int j = i; j < n; j++) {
            if (visited[s.charAt(j)]) {
                break;
            }
            ans = Math.max(ans, j - i + 1);
            visited[s.charAt(j)] = true;
        }
    }
    return ans;
    }
}

203rd Problem
Given an array nums of size n, return the majority element.
The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
Example 1:
Input: nums = [3,2,3]
Output: 3
Example 2:
Input: nums = [2,2,1,1,1,2,2]
Output: 2

class Solution {
    public int majorityElement(int[] nums) {
        int candidate = 0;
        int count = 0;
        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            if (num == candidate) {
                count++;
            } else {
                count--;
            }
        }
        return candidate;
    }
}

204th Problem
There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).
Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].
Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.
Example 1:
Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Example 2:
Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false

class Solution {
    public boolean search(int[] nums, int target) {
        for(int i=0;i<nums.length;i++){
            if(nums[i] == target){
                return true;
            }   
        }
        return false;
    }
}

205th Problem
Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string "".
A string is palindromic if it reads the same forward and backward.
Example 1:
Input: words = ["abc","car","ada","racecar","cool"]
Output: "ada"
Explanation: The first string that is palindromic is "ada".
Note that "racecar" is also palindromic, but it is not the first.

class Solution {
public String firstPalindrome(String[] words) {
    for (String word : words) {
        int left = 0;
        int right = word.length() - 1;
        while (left < right) {
            if (word.charAt(left) != word.charAt(right)) {
                break;
            }
            left++;
            right--;
        }
        if (left >= right) {
            return word;
        }
    }
    return "";
    }
}

206th Problem
Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.
Example 1:
Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

public class Solution {
    public int removeDuplicates(int[] nums) {
        int i = 0;
        for (int num : nums) {
            if (i < 2 || num > nums[i - 2]) {
                nums[i] = num;
                i++;
            }
        }
        return i;
    }
}

207th Problem
Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
The overall run time complexity should be O(log (m+n)).
Example 1:
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
Example 2:
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.

class Solution {
    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int totalLength = nums1.length + nums2.length;
        int[] mergedArray = new int[totalLength];
        int i = 0, j = 0, k = 0;
        while (i < nums1.length && j < nums2.length) {
            if (nums1[i] <= nums2[j]) {
                mergedArray[k++] = nums1[i++];
            } else {
                mergedArray[k++] = nums2[j++];
            }
        }
        while (i < nums1.length) {
            mergedArray[k++] = nums1[i++];
        }

        while (j < nums2.length) {
            mergedArray[k++] = nums2[j++];
        }
        if (totalLength % 2 == 0) {
            int mid1 = mergedArray[totalLength / 2];
            int mid2 = mergedArray[totalLength / 2 - 1];
            return (double) (mid1 + mid2) / 2;
        } else {
            return mergedArray[totalLength / 2];
        }
    }
}    

208th Problem
You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.
You should rearrange the elements of nums such that the modified array follows the given conditions:
Every consecutive pair of integers have opposite signs.
For all integers with the same sign, the order in which they were present in nums is preserved.
The rearranged array begins with a positive integer.
Return the modified array after rearranging the elements to satisfy the aforementioned conditions.
Example 1:
Input: nums = [3,1,-2,-5,2,-4]
Output: [3,-2,1,-5,2,-4]
Explanation:
The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].
The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  
Example 2:
Input: nums = [-1,1]
Output: [1,-1]
Explanation:
1 is the only positive integer and -1 the only negative integer in nums.
So nums is rearranged to [1,-1].

class Solution {
    public int[] rearrangeArray(int[] a) {
        int n=a.length;
        int []ans=new int[n];
       int posIndex=0,negIndex=1;
       for(int i=0;i<n;i++){
           if(a[i]>0){
               ans[posIndex]=a[i];
               posIndex+=2;
           }
           else{
               ans[negIndex]=a[i];
               negIndex+=2;
           }
       }
       return ans;

    }
}

209th Problem
You are given an integer array nums. The unique elements of an array are the elements that appear exactly once in the array.
Return the sum of all the unique elements of nums.
Example 1:
Input: nums = [1,2,3,2]
Output: 4
Explanation: The unique elements are [1,3], and the sum is 4.
Example 2:
Input: nums = [1,1,1,1,1]
Output: 0
Explanation: There are no unique elements, and the sum is 0.

class Solution {
    public int sumOfUnique(int[] nums) {
        int sum = 0;
        HashSet<Integer> uniqueSet = new HashSet<>();
        HashSet<Integer> nonUniqueSet = new HashSet<>();
        for (int num : nums) {
            if (!nonUniqueSet.contains(num)) {
                if (!uniqueSet.contains(num)) {
                    sum += num;
                    uniqueSet.add(num);
                } else {
                    sum -= num;
                    nonUniqueSet.add(num);
                }
            }
        }
        return sum;
    }
}

210th Problem
Given the roots of two binary trees p and q, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
Example 1:
Input: p = [1,2,3], q = [1,2,3]
Output: true

class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null && q==null){
            return true;
        }
        else if(p==null || q==null){
            return false;
        }
        else {
            if(p.val == q.val){
                return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
            }
        }
        return false;
    }
}

211st Problem
Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
Example 1:
Input: root = [1,2,2,3,4,4,3]
Output: true

class Solution {
    public boolean isSymmetric(TreeNode root) {
     if(root == null){
         return true;
     }
     return ismir(root.left,root.right);
    }
    public boolean ismir(TreeNode left, TreeNode right){
        if(left == null && right == null){
            return true;
        }
        if(left == null || right==null){
            return false;
        }
        else{
            if(left.val == right.val){
                return ismir(left.left, right.right) && ismir(left.right,right.left);
            } 
        }
        return false;
    }
}

212nd Problem
You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

class Solution {
    public int climbStairs(int n) {
        int arr[] = new int[n+1];
        if(n==0){
            return 0;
        }
        else if(n == 1){
            return 1;
        }
        else {
            arr[0] = 1;
            arr[1] = 1;
            for(int i=2;i<=n;i++){
                arr[i] = arr[i-1]+arr[i-2];
            }
        }
        return arr[n];
    }
}

213th Problem
Alice and Bob take turns playing a game, with Alice starting first.
Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of:
Choosing any x with 0 < x < n and n % x == 0.
Replacing the number n on the chalkboard with n - x.
Also, if a player cannot make a move, they lose the game.
Return true if and only if Alice wins the game, assuming both players play optimally.
Example 1:
Input: n = 2
Output: true
Explanation: Alice chooses 1, and Bob has no more moves.
Example 2:
Input: n = 3
Output: false
Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.

class Solution {
    public boolean divisorGame(int n) {
        return n%2==0;
    }
}

214th Problem
The Tribonacci sequence Tn is defined as follows: 
T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.
Given n, return the value of Tn.
Example 1:
Input: n = 4
Output: 4
Explanation:
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
Example 2:
Input: n = 25
Output: 1389537

class Solution {
    public int tribonacci(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1 || n == 2) {
            return 1;
        }
        // Compute the Tribonacci number using the recurrence relation
        int t0 = 0, t1 = 1, t2 = 1;
        for (int i = 3; i <= n; i++) {
            int tn = t0 + t1 + t2;
            t0 = t1;
            t1 = t2;
            t2 = tn;
        }
        return t2;
    }
}

215th Problem
Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.
Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:
Change the array nums such that the first k elements of nums contain the elements which are not equal to val. 
Example 1:
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
Example 2:
Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).

class Solution {
    public int removeElement(int[] nums, int val) {
        int k = 0; // Initialize the count of elements not equal to val
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {
                nums[k] = nums[i]; // Move the element to the front
                k++; // Increment k
            }
        }
        return k; // Return the count of valid elements
    }
}

216th Problem
A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
Given a string s, return true if it is a palindrome, or false otherwise.
Example 1:
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
Example 2:
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
Example 3:
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.

class Solution {
    public boolean isPalindrome(String s) {
        // Remove non-alphanumeric characters and convert to lowercase
        StringBuilder cleaned = new StringBuilder();
        for (char ch : s.toCharArray()) {
            if (Character.isLetterOrDigit(ch)) {
                cleaned.append(Character.toLowerCase(ch));
            }
        }

        // Check if the cleaned string is a palindrome
        int left = 0;
        int right = cleaned.length() - 1;
        while (left < right) {
            if (cleaned.charAt(left) != cleaned.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}

217th Problem
Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
Note that you must do this in-place without making a copy of the array.
Example 1:
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
Example 2:
Input: nums = [0]
Output: [0]

class Solution {
    public void moveZeroes(int[] nums) {
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[j++] = nums[i];
            }
        }
        for (int i = j; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
}

218th Problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:
I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral.
Example 1:
Input: num = 3
Output: "III"
Explanation: 3 is represented as 3 ones.
Example 2:
Input: num = 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
Example 3:
Input: num = 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.

class Solution {
    public String intToRoman(int num) {
        StringBuilder result = new StringBuilder();
        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] symbols = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
        for (int i = 0; i < values.length; i++) {
            while (num >= values[i]) {
                result.append(symbols[i]);
                num -= values[i];
            }
        }
        return result.toString();
    }
}

219th Problem
Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.
Example 1:
Input: num1 = "2", num2 = "3"
Output: "6"
Example 2:
Input: num1 = "123", num2 = "456"
Output: "56088"

class Solution {
    public String multiply(String num1, String num2) {
        int m = num1.length();
        int n = num2.length();
        int[] result = new int[m + n]; 
                for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
                int sum = mul + result[i + j + 1]; 
                result[i + j] += sum / 10; 
                result[i + j + 1] = sum % 10; 
            }
        }
        StringBuilder sb = new StringBuilder();
        for (int digit : result) {
            if (!(sb.length() == 0 && digit == 0)) { 
                sb.append(digit);
            }
        }
        
        return sb.length() == 0 ? "0" : sb.toString();
    }
}

220th Problem
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Example 1:
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
Example 2:
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
Example 3:
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.

import java.util.*;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums); // Sort the array to easily handle duplicates
        
        List<List<Integer>> result = new ArrayList<>();
        
        for (int i = 0; i < nums.length - 2; i++) {
            // Avoid duplicates
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            
            int left = i + 1;
            int right = nums.length - 1;
            int target = -nums[i]; // Find two elements that sum up to -nums[i]
            
            while (left < right) {
                int sum = nums[left] + nums[right];
                
                if (sum == target) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    
                    // Skip duplicates
                    while (left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    while (left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    
                    left++;
                    right--;
                } else if (sum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        
        return result;
    }
}

221st Problem
Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string "".
Example 1:
Input: strs = ["flower","flow","flight"]
Output: "fl"
Example 2:
Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.

public class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        
        // Start with the first string as the initial prefix
        String prefix = strs[0];
        
        // Iterate through the array of strings
        for (int i = 1; i < strs.length; i++) {
            // Keep reducing the prefix until it matches the current string
            while (strs[i].indexOf(prefix) != 0) {
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.isEmpty()) {
                    return ""; // If the prefix becomes empty, there's no common prefix
                }
            }
        }
        
        return prefix;
    }
}

222nd Problem
Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.
Example 1:
Input: head = [1,1,2]
Output: [1,2]
Example 2:
Input: head = [1,1,2,3,3]
Output: [1,2,3]

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) {
            return head; // If the list is empty or has only one element, no duplicates to remove
        }
        
        ListNode current = head;
        
        while (current != null && current.next != null) {
            if (current.val == current.next.val) {
                current.next = current.next.next; // Skip the duplicate node
            } else {
                current = current.next; // Move to the next node
            }
        }
        
        return head;
    }
}

223rd Problem
Given the root of a binary tree, return its maximum depth.
A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: 3
Example 2:
Input: root = [1,null,2]
Output: 2

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0; // Base case: if the root is null, return 0
        }
        
        int leftDepth = maxDepth(root.left); // Recursively find the maximum depth of the left subtree
        int rightDepth = maxDepth(root.right); // Recursively find the maximum depth of the right subtree
        
        return Math.max(leftDepth, rightDepth) + 1; // Return the maximum depth among left and right subtrees plus 1 (for the current node)
    }
}

224th Problem
Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.
Return the sum of the three integers.
Example 1:
Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
Example 2:
Input: nums = [0,0,0], target = 1
Output: 0
Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).

import java.util.Arrays;
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums); // Sort the array to facilitate two-pointer approach
        int closestSum = nums[0] + nums[1] + nums[2]; // Initialize with the sum of the first three elements
        for (int i = 0; i < nums.length - 2; i++) {
            int left = i + 1; // Pointer for the element after nums[i]
            int right = nums.length - 1; // Pointer for the last element
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right]; // Calculate the current sum
                // Update closestSum if the current sum is closer to the target
                if (Math.abs(sum - target) < Math.abs(closestSum - target)) {
                    closestSum = sum;
                }
                if (sum < target) {
                    left++; // Move the left pointer to increase the sum
                } else if (sum > target) {
                    right--; // Move the right pointer to decrease the sum
                } else {
                    return sum; // If the sum is equal to target, return immediately
                }
            }
        }
        return closestSum;
    }
}

225th Problem
Given an integer n, return true if it is a power of two. Otherwise, return false.
An integer n is a power of two, if there exists an integer x such that n == 2x.
Example 1:
Input: n = 1
Output: true
Explanation: 2^0 = 1
Example 2:
Input: n = 16
Output: true
Explanation: 2^4 = 16
Example 3:
Input: n = 3
Output: false

class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
}

226th Problem
Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
Example 1:
Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
Example 2:
Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
Example 3:
Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.

class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;
        // Calculate the sum of numbers from 0 to n
        int expectedSum = n * (n + 1) / 2;
        // Calculate the sum of elements in the array
        int actualSum = 0;
        for (int num : nums) {
            actualSum += num;
        }
        // The missing number is the difference between the expected sum and the actual sum
        return expectedSum - actualSum;
    }
}

227th Problem
Write an algorithm to determine if a number n is happy.
A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.
Example 1:
Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
Example 2:
Input: n = 2
Output: false

class Solution {
    public boolean isHappy(int n) {
        int slow = n;
        int fast = n;
        do {
            slow = sumOfSquares(slow);
            fast = sumOfSquares(sumOfSquares(fast));
        } while (slow != fast);

        return slow == 1;
    }
    private int sumOfSquares(int n) {
        int sum = 0;
        while (n > 0) {
            int digit = n % 10;
            sum += digit * digit;
            n /= 10;
        }
        return sum;
    }
}

228th Problem
Write a function that reverses a string. The input string is given as an array of characters s.
You must do this by modifying the input array in-place with O(1) extra memory.
Example 1:
Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]
Example 2:
Input: s = ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]

class Solution {
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length - 1;
        while (left < right) {
            // Swap characters at left and right positions
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            // Move pointers towards the center
            left++;
            right--;
        }
    }
}

229th Problem
Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.
Example 1:
Input: head = [1,2,6,3,4,5,6], val = 6
Output: [1,2,3,4,5]
Example 2:
Input: head = [], val = 1
Output: []
Example 3:
Input: head = [7,7,7,7], val = 7
Output: []

class Solution {
    public ListNode removeElements(ListNode head, int val) {
        // Handle the case where the head itself has the value to be removed
        while (head != null && head.val == val) {
            head = head.next;
        }
        
        ListNode current = head;
        ListNode previous = null;
        
        while (current != null) {
            if (current.val == val) {
                // Skip current node
                previous.next = current.next;
            } else {
                // Move previous pointer
                previous = current;
            }
            // Move current pointer
            current = current.next;
        }
        return head;
    }
}

230th Problem
Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.
Example 1:
Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:
Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:
Input: nums = [1,2,3,1,2,3], k = 2
Output: false

import java.util.*;
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            if (map.containsKey(num)) {
                int prevIndex = map.get(num);
                if (i - prevIndex <= k) {
                    return true;
                }
            }
            map.put(num, i);
        }
        return false;
    }
}

231st Problem
ANAGRAMS
Given two strings s and t, return true if t is an anagram of s, and false otherwise.
An Anagram is a word or phrase formed by rerranging the letters of a different word or phrase, typically using all the original letters exactly once.
Example 1:
Input: s = "anagram", t = "nagaram"
Output: true
Example 2:
Input: s = "rat", t = "car"
Output: false

class Solution {
    public boolean isAnagram(String s, String t) {
        char[] sp=s.toCharArray();
        char[] sk=t.toCharArray();
        Arrays.sort(sp);
        Arrays.sort(sk);
        return (new String(sp)).equals(new String(sk));
    }
}

232nd Problem
Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.
Example 1:
Input: num = 38
Output: 2
Explanation: The process is
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2 
Since 2 has only one digit, return it.
Example 2:
Input: num = 0
Output: 0

class Solution {
    public int addDigits(int num) {
        if (num < 10) {
            return num;
        }
        int total = 0;
        do {
            total += num % 10;
            num /= 10;
        } while (num != 0);
        return addDigits(total);
    }
}

233rd Problem
Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.
Letters are case sensitive, for example, "Aa" is not considered a palindrome here.
Example 1:
Input: s = "abccccdd"
Output: 7
Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.
Example 2:
Input: s = "a"
Output: 1
Explanation: The longest palindrome that can be built is "a", whose length is 1.

class Solution {
    public int longestPalindrome(String s) {
        int[] frequency = new int[128];
        
        for (char c : s.toCharArray()) {
            frequency[c]++;
        }
        
        int palindromeLength = 0;
        boolean oddCount = false;
        
        for (int count : frequency) {
            palindromeLength += count / 2 * 2;
            if (count % 2 != 0) {
                oddCount = true;
            }
        }
        return oddCount ? palindromeLength + 1 : palindromeLength;
    }
}

234th Problem
Given an input string s, reverse the order of the words.
A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.
Return a string of the words in reverse order concatenated by a single space.
Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.
Example 1:
Input: s = "the sky is blue"
Output: "blue is sky the"
Example 2:
Input: s = "  hello world  "
Output: "world hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
Example 3:
Input: s = "a good   example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.

class Solution {
    public String reverseWords(String s) {
        // Split the input string by spaces
        String[] words = s.trim().split("\\s+");
        StringBuilder reversed = new StringBuilder();
        for (int i = words.length - 1; i >= 0; i--) {
            reversed.append(words[i]);
            if (i > 0) {
                reversed.append(" ");
            }
        }
        
        return reversed.toString();
    }
}

235th Problem
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and uses only constant extra space.
Example 1:
Input: nums = [1,3,4,2,2]
Output: 2
Example 2:
Input: nums = [3,1,3,4,2]
Output: 3

class Solution {
    public int findDuplicate(int[] nums) {
       boolean arr[] =new boolean[nums.length];
       for(int num : nums)
            if(arr[num]==false)
                arr[num]=true;
            else
                return num;
       return 0;
    }
}

236th Problem
Given an integer n, return a string array answer (1-indexed) where:
answer[i] == "FizzBuzz" if i is divisible by 3 and 5.
answer[i] == "Fizz" if i is divisible by 3.
answer[i] == "Buzz" if i is divisible by 5.
answer[i] == i (as a string) if none of the above conditions are true.
Example 1:
Input: n = 3
Output: ["1","2","Fizz"]
Example 2:
Input: n = 5
Output: ["1","2","Fizz","4","Buzz"]
Example 3:
Input: n = 15
Output: ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]
 
import java.util.*;
class Solution {
    public List<String> fizzBuzz(int n) {
        List<String> answer = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            if (i % 3 == 0 && i % 5 == 0) {
                answer.add("FizzBuzz");
            } else if (i % 3 == 0) {
                answer.add("Fizz");
            } else if (i % 5 == 0) {
                answer.add("Buzz");
            } else {
                answer.add(String.valueOf(i));
            }
        }
        return answer;
    }
}

237th Problem
Given the root of a binary tree, return the length of the diameter of the tree.
The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
The length of a path between two nodes is represented by the number of edges between them.
Example 1:
Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
Example 2:
Input: root = [1,2]
Output: 1

class Solution {
    int maxDiameter = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        calculateDiameter(root);
        return maxDiameter;
    }
    private int calculateDiameter(TreeNode node) {
        if (node == null) return 0;

        int leftHeight = calculateDiameter(node.left);
        int rightHeight = calculateDiameter(node.right);
        // Update the maximum diameter
        maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight);
        // Return the height of the current subtree
        return 1 + Math.max(leftHeight, rightHeight);
    }
}

238th Problem
Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.
Example 1:
Input: nums = [2,2,1]
Output: 1
Example 2:
Input: nums = [4,1,2,1,2]
Output: 4
Example 3:
Input: nums = [1]
Output: 1

class Solution {
    public int singleNumber(int[] nums) {
        int count = 0;
        for(int i = 0; i < nums.length; i++) {
            count ^= nums[i];
        }
        return count;
    }
}

239th Problem
Given the root of a binary tree, return the leftmost value in the last row of the tree.
Example 1:
Input: root = [2,1,3]
Output: 1
Example 2:
Input: root = [1,2,3,4,null,5,6,null,null,7]
Output: 7

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int leftmost = 0;
    int leftmostrow = -1;
    void visit(TreeNode root, int depth) {
        if (root == null) return;
        if (depth > leftmostrow) {
            leftmost = root.val;
            leftmostrow = depth;
        }
        visit(root.left, depth+1);
        visit(root.right, depth+1);
    }
    public int findBottomLeftValue(TreeNode root) {
        visit(root, 0)    ;
        return leftmost;
    }
}

240th Problem
Given head, the head of a linked list, determine if the linked list has a cycle in it.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.
Return true if there is a cycle in the linked list. Otherwise, return false.
Example 1:
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
Example 2:
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.

public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false; // No cycle if the list is empty or has only one node
        }
        ListNode tortoise = head;
        ListNode hare = head;
        while (hare != null && hare.next != null) {
            tortoise = tortoise.next;
            hare = hare.next.next;
            if (tortoise == hare) {
                return true; // Cycle detected
            }
        }
        return false; // No cycle detected
    }
}

241st Problem
The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).
For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.
Return the maximum such product difference.
Example 1:
Input: nums = [5,6,2,7,4]
Output: 34
Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).
The product difference is (6 * 7) - (2 * 4) = 34.

class Solution {
    public int maxProductDifference(int[] nums) {
      int max1=Integer.MIN_VALUE;
      int max2=Integer.MIN_VALUE;
      int min1=Integer.MAX_VALUE;
      int min2=Integer.MAX_VALUE;
      for(int n : nums){
          if(n>max1){
              max2=max1;
              max1=n;
          }
          else if(n>max2){
              max2=n;
          }
          if(n<min1){
              min2=min1;
              min1=n;
          }
          else if(n<min2){
              min2=n;
          }
      }
      return (max1*max2)-(min1*min2);
    }
}

242nd Problem
Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).
Example 1:
Input: nums = [3,4,5,2]
Output: 12 
Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. 
Example 2:
Input: nums = [1,5,4,5]
Output: 16
Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.

class Solution {
    public int maxProduct(int[] nums) {
        int max1 = Integer.MIN_VALUE;
        int max2 = Integer.MIN_VALUE;
        for (int num : nums) {
            if (num >= max1) {
                max2 = max1;
                max1 = num;
            } else if (num > max2) {
                max2 = num;
            }
        }
        return (max1 - 1) * (max2 - 1);
    }
}

243rd Problem
Given an array of integers nums, return the number of good pairs.
A pair (i, j) is called good if nums[i] == nums[j] and i < j.
Example 1:
Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
Example 2:
Input: nums = [1,1,1,1]
Output: 6
Explanation: Each pair in the array are good.
Example 3:
Input: nums = [1,2,3]
Output: 0

class Solution {
    public int numIdenticalPairs(int[] nums) {
        int count = 0;
        int[] frequency = new int[101];
        for (int num : nums) {
            count += frequency[num];
            frequency[num]++;
        }
        return count;
    }
}

244th Problem
You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.
You can either start from the step with index 0, or the step with index 1.
Return the minimum cost to reach the top of the floor.
Example 1:
Input: cost = [10,15,20]
Output: 15
Explanation: You will start at index 1.
- Pay 15 and climb two steps to reach the top.
The total cost is 15.
Example 2:
Input: cost = [1,100,1,1,1,100,1,1,100,1]
Output: 6
Explanation: You will start at index 0.
- Pay 1 and climb two steps to reach index 2.
- Pay 1 and climb two steps to reach index 4.
- Pay 1 and climb two steps to reach index 6.
- Pay 1 and climb one step to reach index 7.
- Pay 1 and climb two steps to reach index 9.
- Pay 1 and climb one step to reach the top.
The total cost is 6.

public class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n + 1];
        // Base cases
        dp[0] = cost[0];
        dp[1] = cost[1];
        // Calculate minimum cost for each step
        for (int i = 2; i <= n; i++) {
            if (i == n) {
                dp[i] = Math.min(dp[i - 1], dp[i - 2]);
            } else {
                dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
            }
        }
        return dp[n];
    }
}

250th Problem
Given an integer n, return true if it is a power of four. Otherwise, return false.
An integer n is a power of four, if there exists an integer x such that n == 4x.
Example 1:
Input: n = 16
Output: true
Example 2:
Input: n = 5
Output: false
Example 3:
Input: n = 1
Output: true

public class Solution {
    public boolean isPowerOfFour(int n) {
        if (n <= 0) {
            return false;
        }
        while (n > 1) {
            if (n % 4 != 0) {
                return false;
            }
            n /= 4;
        }   
        return true;
    }
}

251st Problem
Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. 
Example 1:
Input: nums = [-4,-1,0,3,10]
Output: [0,1,9,16,100]
Explanation: After squaring, the array becomes [16,1,0,9,100].
After sorting, it becomes [0,1,9,16,100].
Example 2:
Input: nums = [-7,-3,2,3,11]
Output: [4,9,9,49,121]

class Solution {
    public int[] sortedSquares(int[] nums) {
        int res[]=new int[nums.length];
        int start=0;
        int last=nums.length-1;
        for(int i=nums.length-1;i>=0;i--){
            int rightsquare=nums[last]*nums[last];
            int leftsquare=nums[start]*nums[start];
            if(leftsquare>rightsquare){
                res[i]=leftsquare;
                start++;
            }else{
                res[i]=rightsquare;
                last--;
            }
        }
        return res;
    }
}

252nd Problem
Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.
A string is represented by an array if the array elements concatenated in order forms the string.
Example 1:
Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
Output: true
Explanation:
word1 represents string "ab" + "c" -> "abc"
word2 represents string "a" + "bc" -> "abc"
The strings are the same, so return true.
Example 2:
Input: word1 = ["a", "cb"], word2 = ["ab", "c"]
Output: false
Example 3:
Input: word1  = ["abc", "d", "defg"], word2 = ["abcddefg"]
Output: true

public class Solution {
    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {
        StringBuilder sb1 = new StringBuilder();
        StringBuilder sb2 = new StringBuilder();
        for (String str : word1) {
            sb1.append(str);
        }
        
        for (String str : word2) {
            sb2.append(str);
        }
        return sb1.toString().equals(sb2.toString());
    }
}

253rd Problem
Given the head of a linked list, remove the nth node from the end of the list and return its head.
Example 1:
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
Example 2:
Input: head = [1], n = 1
Output: []
Example 3:
Input: head = [1,2], n = 1
Output: [1]

class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // Create a dummy node to handle edge cases where the head needs to be removed
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        
        // Initialize two pointers
        ListNode fast = dummy;
        ListNode slow = dummy;
        
        // Move the fast pointer to the nth node from the beginning
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
        }
        
        // Move both pointers simultaneously until the fast pointer reaches the end
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        
        // Remove the nth node from the end
        slow.next = slow.next.next;
        
        // Return the modified list
        return dummy.next;
    }
}

254th Problem
Given an integer n, return the least number of perfect square numbers that sum to n.
A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.
Example 1:
Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
Example 2:
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.

class Solution {
    public int numSquares(int n) {
        while(n%4 == 0)  n /= 4;
        if(n%8 == 7) return 4;
        for(int x=0; x*x <=n; x++){
            int y = (int)Math.sqrt(n - x*x);
            if(x*x + y*y == n){
                if(x == 0 || y == 0) return 1;
                else return 2;
            }
        }
        return 3;
    }
}

255th Problem
Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.
Note that after backspacing an empty text, the text will continue empty.
Example 1:
Input: s = "ab#c", t = "ad#c"
Output: true
Explanation: Both s and t become "ac".
Example 2:
Input: s = "ab##", t = "c#d#"
Output: true
Explanation: Both s and t become "".
Example 3:
Input: s = "a#c", t = "b"
Output: false
Explanation: s becomes "c" while t becomes "b".

class Solution {
    public boolean backspaceCompare(String s, String t) {
            return buildString(s).equals(buildString(t));
    }
    public String buildString(String s) {
        StringBuilder stack = new StringBuilder();
        for (char ch : s.toCharArray()) {
            if (ch == '#' && stack.length() > 0) {
                stack.deleteCharAt(stack.length() - 1);
            } else {
                if (ch != '#') {
                    stack.append(ch);
                }
            }
        }
        return stack.toString();
    }
}

256th Problem
Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).
Example 1:
Input: n = 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
Example 2:
Input: n = 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
Example 3:
Input: n = 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.

public class Solution {
    public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            count += n & 1;
            n >>>= 1;
        }
        return count;
    }
}

257th Problem
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Example 1:
Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = 3.33333.. which is truncated to 3.
Example 2:
Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = -2.33333.. which is truncated to -2.

class Solution {
    public int divide(int dividend, int divisor) {
         if (dividend == Integer.MIN_VALUE && divisor == -1) {
            return Integer.MAX_VALUE;
        }
     int ans = dividend/divisor;
     return ans;
    }
}

258th Problem
Given the head of a singly linked list, return the middle node of the linked list.
If there are two middle nodes, return the second middle node.
Example 1:
Input: head = [1,2,3,4,5]
Output: [3,4,5]
Explanation: The middle node of the list is node 3.
Example 2:
Input: head = [1,2,3,4,5,6]
Output: [4,5,6]
Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}

259th Problem
You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string "" if no odd integer exists.
A substring is a contiguous sequence of characters within a string.
Example 1:
Input: num = "52"
Output: "5"
Explanation: The only non-empty substrings are "5", "2", and "52". "5" is the only odd number.
Example 2:
Input: num = "4206"
Output: ""
Explanation: There are no odd numbers in "4206".
Example 3:
Input: num = "35427"
Output: "35427"
Explanation: "35427" is already an odd number.

public class Solution {
    public String largestOddNumber(String num) {
        int n = num.length();
        for (int i = n - 1; i >= 0; i--) {
            int digit = num.charAt(i) - '0';
            if (digit % 2 == 1) {
                return num.substring(0, i + 1);
            }
        }
        return "";
    }
}

260th Problem
You are given an array nums consisting of positive integers.
Return the total frequencies of elements in nums such that those elements all have the maximum frequency.
The frequency of an element is the number of occurrences of that element in the array.
Example 1:
Input: nums = [1,2,2,3,1,4]
Output: 4
Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.
So the number of elements in the array with maximum frequency is 4.
Example 2:
Input: nums = [1,2,3,4,5]
Output: 5
Explanation: All elements of the array have a frequency of 1 which is the maximum.
So the number of elements in the array with maximum frequency is 5.

class Solution {
    public int maxFrequencyElements(int[] nums) {
        int a[]=new int[101];
        for(int i:nums)
        {
            a[i]++;
        }
        int maxi=0;
        for(int i=0;i<=100;i++)
        {
            maxi=Math.max(maxi,a[i]);
        }
        int ans=0;
        for(int i=0;i<=100;i++)
        {
            if(a[i]==maxi)
            {
                ans+=maxi;
            }
        }
        return ans;
    }
}

261st Problem
You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.
You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.
Return the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.
Example 1:
Input: prices = [1,2,2], money = 3
Output: 0
Explanation: Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.
Example 2:
Input: prices = [3,2,3], money = 3
Output: 3
Explanation: You cannot buy 2 chocolates without going in debt, so we return 3.

class Solution {
    public int buyChoco(int[] prices, int money) {
        Arrays.sort(prices);
        int num=money;
        for (int i =0;i<prices.length;i++){
            if (money>=0){
                num-=prices[i];
                if (i==1){
                    break;
                }
            }
        }
        if (num<0){
            return money;
        }
        return num;
    }
}

262nd Problem
Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.
Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.
Example 1:
Input: nums1 = [1,2,3], nums2 = [2,4]
Output: 2
Explanation: The smallest element common to both arrays is 2, so we return 2.
Example 2:
Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]
Output: 2
Explanation: There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.

class Solution {
    public int getCommon(int[] nums1, int[] nums2) {
        int n1, n2, max, i = 0, j = 0;
        while (i < nums1.length && j < nums2.length) {
            n1 = nums1[i];
            n2 = nums2[j];
            if (n1 < n2) {
                i++;
            } else if (n1 > n2) {
                j++;
            } else {
                return n1;
            }
        }
        return -1;
    }
}

263rd Problem
Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]]
nums[a] + nums[b] + nums[c] + nums[d] == target
You may return the answer in any order.
Example 1:
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
Example 2:
Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        int n= nums.length;
        if(nums==null || n==0) return ans;
        Arrays.sort(nums);
        int i,j;
        for(i=0;i<n;i++){
            for(j=i+1;j<n;j++){
                long find = (long)target - (long)(nums[i]+nums[j]);
                int left = j+1;
                int right = n-1;
                while(left<right){
                    long sum = (long)nums[left]+(long)nums[right];
                    if(find>sum) left++;
                    else if(find<sum) right--;
                    else{
                        List<Integer> tem = new ArrayList<>();
                        tem.add(nums[i]); tem.add(nums[j]);
                        tem.add(nums[left]); tem.add(nums[right]);
                        ans.add(tem);
                        
                        while(left<right && nums[left]==tem.get(2)) ++left;
                        while(left<right && nums[right]==tem.get(3)) --right;
                    }
                }
                while(j+1<n && nums[j]==nums[j+1]) ++j;
            }
            while(i+1<n && nums[i]==nums[i+1]) ++i;
        }
        return ans;
    }
}

264th Problem
Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.
Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.

import java.util.*;
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set = new HashSet<>();
        Set<Integer> intersect = new HashSet<>();
        // Add elements from nums1 to set
        for (int num : nums1) {
            set.add(num);
        }
        // Check if elements in nums2 exist in set, if so, add to intersect
        for (int num : nums2) {
            if (set.contains(num)) {
                intersect.add(num);
            }
        }
        // Convert set to array
        int[] result = new int[intersect.size()];
        int index = 0;
        for (int num : intersect) {
            result[index++] = num;
        }
        return result;
    }
}

265th Problem
Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.
A substring is a contiguous sequence of characters within a string.
Example 1:
Input: s = "aa"
Output: 0
Explanation: The optimal substring here is an empty substring between the two 'a's.
Example 2:
Input: s = "abca"
Output: 2
Explanation: The optimal substring here is "bc".
Example 3:
Input: s = "cbzxy"
Output: -1
Explanation: There are no characters that appear twice in s.

class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
        Map<Character, Integer> firstOccur = new HashMap<>();
        int ans = -1;
        for(int i = 0; i < s.length(); i++) {
            if(firstOccur.containsKey(s.charAt(i))) {
                ans = Math.max(ans, i - firstOccur.get(s.charAt(i)) - 1);
            }
            else {
                firstOccur.put(s.charAt(i), i);
            }
        }
        return ans;   
    }
}

266th Problem
You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously.
Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string.
Return any permutation of s that satisfies this property.
Example 1:
Input:  order = "cba", s = "abcd" 
Output:  "cbad" 
Explanation: "a", "b", "c" appear in order, so the order of "a", "b", "c" should be "c", "b", and "a".
Since "d" does not appear in order, it can be at any position in the returned string. "dcba", "cdba", "cbda" are also valid outputs.
Example 2:
Input:  order = "bcafg", s = "abcd" 
Output:  "bcad" 
Explanation: The characters "b", "c", and "a" from order dictate the order for the characters in s. The character "d" in s does not appear in order, so its position is flexible.

import java.util.HashMap;
class Solution {
    public String customSortString(String order, String s) {
        StringBuilder result = new StringBuilder();
        HashMap<Character, Integer> mp = new HashMap<>();
        for (char c : s.toCharArray()) {
            mp.put(c, mp.getOrDefault(c, 0) + 1);
        }
        for (char c : order.toCharArray()) {
            if (mp.containsKey(c)) {
                result.append(String.valueOf(c).repeat(Math.max(0, mp.get(c))));
                mp.remove(c);
            }
        }
        for (char c : mp.keySet()) {
            result.append(String.valueOf(c).repeat(Math.max(0, mp.get(c))));
        }
        return result.toString();
    }
}

267th Problem
You are given a binary string s that contains at least one '1'.
You have to rearrange the bits in such a way that the resulting binary number is the maximum odd binary number that can be created from this combination.
Return a string representing the maximum odd binary number that can be created from the given combination.
Note that the resulting string can have leading zeros.
Example 1:
Input: s = "010"
Output: "001"
Explanation: Because there is just one '1', it must be in the last position. So the answer is "001".
Example 2:
Input: s = "0101"
Output: "1001"
Explanation: One of the '1's must be in the last position. The maximum number that can be made with the remaining digits is "100". So the answer is "1001".

class Solution {
    public String maximumOddBinaryNumber(String s) {
        int cnt1 = 0, cnt0 = 0;
        for (char a : s.toCharArray()) {
            if (a == '1') cnt1++;
            else if (a == '0') cnt0++;
        }
        StringBuilder ans = new StringBuilder();
        ans.append("1".repeat(cnt1 - 1));
        ans.append("0".repeat(cnt0));
        ans.append("1");
        return ans.toString();
    }
}

268th Problem
Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.
After doing so, return the head of the final linked list.  You may return any such answer.
(Note that in the examples below, all sequences are serializations of ListNode objects.)
Example 1:
Input: head = [1,2,-3,3,1]
Output: [3,1]
Note: The answer [1,2,1] would also be accepted.
Example 2:
Input: head = [1,2,3,-3,4]
Output: [1,2,4]
Example 3:
Input: head = [1,2,3,-3,-2]
Output: [1]
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

class Solution {
    public ListNode removeZeroSumSublists(ListNode head) {
        if(head == null)return head;
        ListNode prev = null;
        ListNode cur = head;
        int  running_sum=0;
        while(cur!=null)
        {
            running_sum += cur.val;
            if(running_sum==0)
            {
                if(prev == null)
                head = cur.next;
                else
                prev.next = cur.next;
                return removeZeroSumSublists(head);
            }
            cur = cur.next;
        }
        head.next = removeZeroSumSublists(head.next);
        return head;
    }
}

270th Problem
Given an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.
Example 1:
Input: arr = [5,5,4], k = 1
Output: 1
Explanation: Remove the single 4, only 5 is left.
Example 2:
Input: arr = [4,3,1,1,3,3,2], k = 3
Output: 2
Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.

class Solution {
    public int findLeastNumOfUniqueInts(int[] arr, int k) {
        Map<Integer, Integer> mp = new HashMap<>();
        for (int a : arr) mp.put(a, mp.getOrDefault(a, 0) + 1);
        List<Integer> v = new ArrayList<>();
        int cnt = 0;
        for (int a : mp.values()) {
            v.add(a);
        }
        Collections.sort(v);
        for (int i = 0; i < v.size(); i++) {
            if (k > v.get(i)) {
                k -= v.get(i);
                v.set(i, 0);
            } else {
                v.set(i, v.get(i) - k);
                k = 0;
            }
            if (v.get(i) != 0) cnt++;
        }
        return cnt;
    }
}

271st Problem
Given a positive integer n, find the pivot integer x such that:
The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.
Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.
Example 1:
Input: n = 8
Output: 6
Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.
Example 2:
Input: n = 1
Output: 1
Explanation: 1 is the pivot integer since: 1 = 1.
Example 3:
Input: n = 4
Output: -1

class Solution {
    public int pivotInteger(int n) {
        int sum= n*(n+1)/2;
        double a= Math.sqrt(sum);
        if( a- Math.ceil(a)==0) return (int)a;
        else return -1;
    }
}

272nd Problem
You are given a string num representing a large integer. An integer is good if it meets the following conditions:
It is a substring of num with length 3.
It consists of only one unique digit.
Return the maximum good integer as a string or an empty string "" if no such integer exists.
Example 1:
Input: num = "6777133339"
Output: "777"
Explanation: There are two distinct good integers: "777" and "333".
"777" is the largest, so we return "777".
Example 2:
Input: num = "2300019"
Output: "000"
Explanation: "000" is the only good integer.

class Solution {
    public String largestGoodInteger(String num) {
        if(num.contains("999")){
            return "999";
        }
        else if(num.contains("888")){
            return "888";
        }
        else if(num.contains("777")){
            return "777";
        }
        else if(num.contains("666")){
            return "666";
        }
        else if(num.contains("555")){
            return "555";
        }
        else if(num.contains("444")){
            return "444";
        }
        else if(num.contains("333")){
            return "333";
        }
        else if(num.contains("222")){
            return "222";
        }
        else if(num.contains("111")){
            return "111";
        }
        else if(num.contains("000")){
            return "000";
        }
        else{
            return "";
        }
    }
}

273rd Problem
Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.
A subarray is a contiguous part of the array.
Example 1:
Input: nums = [1,0,1,0,1], goal = 2
Output: 4
Explanation: The 4 subarrays are bolded and underlined below:
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]
[1,0,1,0,1]

import java.util.*;
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        int i = 0, count = 0, res = 0;
        for (int j = 0; j < nums.length; ++j) {
            if (nums[j] == 1) {
                goal--;
                count = 0;
            }
            while (goal == 0 && i <= j) {
                goal += nums[i];
                i++;
                count++;
                if (i > j - goal + 1)
                    break;
            }
            while (goal < 0) {
                goal += nums[i];
                i++;
            }
            res += count;
        }
        return res;
    }
}

274th Problem
Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
You must write an algorithm that runs in O(n) time and without using the division operation.
Example 1:
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Example 2:
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]

class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] answer = new int[n];
        // Calculating prefix products
        int[] prefixProduct = new int[n];
        prefixProduct[0] = 1;
        for (int i = 1; i < n; i++) {
            prefixProduct[i] = prefixProduct[i - 1] * nums[i - 1];
        }
        // Calculating suffix products
        int suffixProduct = 1;
        for (int i = n - 1; i >= 0; i--) {
            answer[i] = prefixProduct[i] * suffixProduct;
            suffixProduct *= nums[i];
        }
        return answer;
    }
}

275th Problem
Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.
Example 1:
Input: nums = [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.
Example 2:
Input: nums = [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.

class Solution {
    public int findMaxLength(int[] nums) {
        int N = nums.length;
        int[] mp = new int[2*N+2];
        int current = N;
        int result = 0;
        for(int i = 0; i < N; i++) {
            current += (nums[i] << 1) - 1;
            if(current == N) {
                result = i+1;
            }
            else if(mp[current] == 0) {
                mp[current] = i+1;
            }
            else {
                result = Math.max(result, i - mp[current]+1);
            }
        }
        return result;
    }
}

276th Problem
You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.
Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).
Return intervals after the insertion.
Example 1:
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
Example 2:
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].

import java.util.*;
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> result = new ArrayList<>();
        int i = 0;
        // Add all intervals before newInterval that don't overlap
        while (i < intervals.length && intervals[i][1] < newInterval[0]) {
            result.add(intervals[i]);
            i++;
        }
        // Merge overlapping intervals
        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
            i++;
        }
        result.add(newInterval); // Add merged interval
        // Add remaining intervals
        while (i < intervals.length) {
            result.add(intervals[i]);
            i++;
        }
        return result.toArray(new int[result.size()][]);
    }
}

277th Problem
There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.
Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.
Given the array points, return the minimum number of arrows that must be shot to burst all balloons.
Example 1:
Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].
Example 2:
Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows
 
class Solution {
    static void quicksort(int[][] points,int low,int high) {
        if(low<high) {
            int i=low;
            int j=high;
            int mid=(low+high)/2;
            int pivot=points[mid][1];
            while(true){
                while(points[i][1]<pivot) {
                    i++;
                }
                while(points[j][1]>pivot) {
                    j--;
                }
                if(i>=j) {
                    break;
                }
                int[] temp=points[i];
                points[i]=points[j];
                points[j]=temp;
                i++;
                j--;

            }
            quicksort(points,low,j);
            quicksort(points,j+1,high);
        }
    }
    public int findMinArrowShots(int[][] points) {
        if (points.length == 0) {
            return 0;
        }
        quicksort(points, 0, points.length - 1);
        int cnt = 0;
        int prevEnd = Integer.MAX_VALUE;
        for (int i = 0; i < points.length; ++i) {
            int[] curr = points[i];
            int currStart = curr[0];
            int currEnd = curr[1];
            if (currStart <= prevEnd) {
                prevEnd = Math.min(currEnd, prevEnd);
            } else {
                ++cnt;
                prevEnd = currEnd;
            }
        }
        return cnt + 1;
    }
}

278th Problem
You are given an array of CPU tasks, each represented by letters A to Z, and a cooling time, n. Each cycle or interval allows the completion of one task. Tasks can be completed in any order, but there's a constraint: identical tasks must be separated by at least n intervals due to cooling time.
​Return the minimum number of intervals required to complete all tasks.
Example 1:
Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: A possible sequence is: A -> B -> idle -> A -> B -> idle -> A -> B.
After completing task A, you must wait two cycles before doing A again. The same applies to task B. In the 3rd interval, neither A nor B can be done, so you idle. By the 4th cycle, you can do A again as 2 intervals have passed.
Example 2:
Input: tasks = ["A","C","A","B","D","B"], n = 1
Output: 6
Explanation: A possible sequence is: A -> B -> C -> D -> A -> B.

import java.util.*;
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] frequencies = new int[26]; // Assuming only capital letters from A to Z
        for (char task : tasks) {
            frequencies[task - 'A']++;
        }
        Arrays.sort(frequencies);
        int maxFrequency = frequencies[25] - 1; // Maximum frequency of a task
        int idleSlots = maxFrequency * n; // Number of idle slots
        for (int i = 24; i >= 0 && frequencies[i] > 0; i--) {
            idleSlots -= Math.min(frequencies[i], maxFrequency);
        }
        return idleSlots > 0 ? idleSlots + tasks.length : tasks.length;
    }
}

279th Problem
You are given two linked lists: list1 and list2 of sizes n and m respectively.
Remove list1's nodes from the ath node to the bth node, and put list2 in their place.
Example 1:
Input: list1 = [10,1,13,6,9,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
Output: [10,1,13,1000000,1000001,1000002,5]
Explanation: We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result.
Example 2:
Input: list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]
Output: [0,1,1000000,1000001,1000002,1000003,1000004,6]
Explanation: The blue edges and nodes in the above figure indicate the result.

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {
        ListNode prev = list1, temp1 = list1, curr = list1;
        a--; // Adjust a to match zero-based indexing
        // Traverse list1 to find the node at position (a-1)
        while (temp1 != null && a-- > 0) {
            temp1 = temp1.next;
            prev = temp1;
        }
        temp1 = list1; // Reset temp1 to traverse list1 again
        // Traverse list1 to find the node at position (b+1)
        while (temp1 != null && b-- > 0) {
            temp1 = temp1.next;
            curr = temp1;
        }
        ListNode temp2 = list2; // Initialize pointer to traverse list2
        // Traverse list2 to find the last node
        while (temp2.next != null) {
            temp2 = temp2.next;
        }
        prev.next = list2; // Connect the node before position 'a' to the head of list2
        temp2.next = curr.next; // Connect the last node of list2 to the node after position 'b'
        return list1; // Return the head of list1
    }
}

280th Problem
Given the head of a singly linked list, reverse the list, and return the reversed list.
Example 1:
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
Example 2:
Input: head = [1,2]
Output: [2,1]
Example 3:
Input: head = []
Output: []

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;
        ListNode nextNode = null;
        while (current != null) {
            nextNode = current.next; // Store the next node
            current.next = prev; // Reverse the pointer
            
            // Move pointers one position ahead
            prev = current;
            current = nextNode;
        }
        // Prev will be pointing to the last node after the loop
        // which is the new head of the reversed list
        return prev;
    }
}

281st Problem
Given the head of a singly linked list, return true if it is a palindrome or false otherwise.
Example 1:
Input: head = [1,2,2,1]
Output: true
Example 2:
Input: head = [1,2]
Output: false
/* Definition for singly-linked list.
  public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
  }
 */
class Solution {
    public boolean isPalindrome(ListNode head) 
    {
        if(head == null || head.next==null){
            return true;
        }
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode curr = slow;
        ListNode prev = null;
        ListNode next;
        while(curr != null){
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        ListNode right = prev;
        ListNode left = head;
        while(right != null){
            if(right.val != left.val){
                return false;
            }
            right = right.next;
            left = left.next;
        } 
        return true;    
    }
}

282nd Problem
You are given the head of a singly linked-list. The list can be represented as:
L0 → L1 → … → Ln - 1 → Ln
Reorder the list to be on the following form:
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
You may not modify the values in the list's nodes. Only nodes themselves may be changed.
Example 1:
Input: head = [1,2,3,4]
Output: [1,4,2,3]
Example 2:
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
/*
 Definition for singly-linked list.
  public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
  }
 */
class Solution {
    private ListNode temp;
    private boolean isStop;
    public void reorderList(ListNode head) {
        temp = head;
        isStop = false;
        reorder(head);
    }
    private void reorder(ListNode head) {
        if (head == null) return;
        reorder(head.next);
        if (!isStop) {
            ListNode next = temp.next;
            temp.next = head;
            head.next = next;
            temp = next;
        }
        if (temp != null && temp.next == head) {
            temp.next = null;
            isStop = true;
        }
    }
}

283rd Problem
Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.
You must write an algorithm that runs in O(n) time and uses only constant extra space.
Example 1:
Input: nums = [4,3,2,7,8,2,3,1]
Output: [2,3]
Example 2:
Input: nums = [1,1,2]
Output: [1]
Example 3:
Input: nums = [1]
Output: []

class Solution {
    public List<Integer> findDuplicates(int[] nums) {
     List<Integer> res = new ArrayList<Integer>();
     int[]count = new int[nums.length+1];
     for(int freq : nums) 
            count[freq]++;
     for( int i =1 ; i <= nums.length ; i++)
    {
        if(count[i] == 2){
            res.add(i);
        }
     }
     return res;  
    }
}

284th Problem
Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.
You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.
Example 1:
Input: nums = [1,2,0]
Output: 3
Explanation: The numbers in the range [1,2] are all in the array.
Example 2:
Input: nums = [3,4,-1,1]
Output: 2
Explanation: 1 is in the array but 2 is missing.
Example 3:
Input: nums = [7,8,9,11,12]
Output: 1
Explanation: The smallest positive integer 1 is missing.

class Solution {
    // Function to swap elements in the array
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        // Place each positive integer i at index i-1 if possible
        for (int i = 0; i < n; i++) {
            while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
                swap(nums, i, nums[i] - 1);
            }
        }
        // Find the first missing positive integer
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }   
        // If all positive integers from 1 to n are present, return n + 1
        return n + 1;
    }
}

285th Problem
Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.
Example 1:
Input: nums = [10,5,2,6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.
Example 2:
Input: nums = [1,2,3], k = 0
Output: 0

class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if (k <= 1) return 0;
        int count = 0;
        int product = 1;
        int left = 0;
        for (int right = 0; right < nums.length; right++) {
            product *= nums[right];
            while (product >= k) {
                product /= nums[left];
                left++;
            }
            count += right - left + 1;
        }
        return count;
    }
}

286th Problem
You are given an integer array nums and an integer k.
The frequency of an element x is the number of times it occurs in an array.
An array is called good if the frequency of each element in this array is less than or equal to k.
Return the length of the longest good subarray of nums.
A subarray is a contiguous non-empty sequence of elements within an array.
Example 1:
Input: nums = [1,2,3,1,2,3,1,2], k = 2
Output: 6
Explanation: The longest possible good subarray is [1,2,3,1,2,3] since the values 1, 2, and 3 occur at most twice in this subarray. Note that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also good.
It can be shown that there are no good subarrays with length more than 6.
Example 2:
Input: nums = [1,2,1,2,1,2,1,2], k = 1
Output: 2
Explanation: The longest possible good subarray is [1,2] since the values 1 and 2 occur at most once in this subarray. Note that the subarray [2,1] is also good.
It can be shown that there are no good subarrays with length more than 2.

class Solution {
    public int maxSubarrayLength(int[] nums, int k) {
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        for (int num : nums) {
            min = Math.min(min, num);
            max = Math.max(max, num);
        }
        int[] frequencies = new int[max - min + 1];
        int left = 0;
        int maxWindow = 0;
        for (int right = 0; right < nums.length; right++) {
            frequencies[nums[right] - min]++;
            while (frequencies[nums[right] - min] > k) {
                frequencies[nums[left] - min]--;

                left++;
            }
            maxWindow = Math.max(maxWindow, right - left + 1);
        }
        return maxWindow;
    }
}

287th Problem
You start with an initial power of power, an initial score of 0, and a bag of tokens given as an integer array tokens, where each tokens[i] denotes the value of tokeni.
Your goal is to maximize the total score by strategically playing these tokens. In one move, you can play an unplayed token in one of the two ways (but not both for the same token):
Face-up: If your current power is at least tokens[i], you may play tokeni, losing tokens[i] power and gaining 1 score.
Face-down: If your current score is at least 1, you may play tokeni, gaining tokens[i] power and losing 1 score.
Return the maximum possible score you can achieve after playing any number of tokens.
Example 1:
Input: tokens = [100], power = 50
Output: 0
Explanation: Since your score is 0 initially, you cannot play the token face-down. You also cannot play it face-up since your power (50) is less than tokens[0] (100).
Example 2:
Input: tokens = [200,100], power = 150
Output: 1
Explanation: Play token1 (100) face-up, reducing your power to 50 and increasing your score to 1.
There is no need to play token0, since you cannot play it face-up to add to your score. The maximum score achievable is 1.

class Solution {
    public int bagOfTokensScore(int[] tokens, int power) {
        Arrays.sort(tokens);
        int l=0,r=tokens.length-1;
        int score=0,maxScore=0;
        while(l<=r){
            if(tokens[l]<=power){
                power -=tokens[l];
                score++;
                l++;
               maxScore=Math.max(score,maxScore); 
            }else if(score>0){
                power += tokens[r];
                r--;
                score--;
            }else{
                break;
            }
        }
        return maxScore;
    }
}

288th Problem
Given a string s consisting only of characters 'a', 'b', and 'c'. You are asked to apply the following algorithm on the string any number of times:
Pick a non-empty prefix from the string s where all the characters in the prefix are equal.
Pick a non-empty suffix from the string s where all the characters in this suffix are equal.
The prefix and the suffix should not intersect at any index.
The characters from the prefix and suffix must be the same.
Delete both the prefix and the suffix.
Return the minimum length of s after performing the above operation any number of times (possibly zero times).
Example 1:
Input: s = "ca"
Output: 2
Explanation: You can't remove any characters, so the string stays as is.
Example 2:
Input: s = "cabaabac"
Output: 0
Explanation: An optimal sequence of operations is:
- Take prefix = "c" and suffix = "c" and remove them, s = "abaaba".
- Take prefix = "a" and suffix = "a" and remove them, s = "baab".
- Take prefix = "b" and suffix = "b" and remove them, s = "aa".
- Take prefix = "a" and suffix = "a" and remove them, s = "".

class Solution {
    public int minimumLength(String s) {
        int left = 0;
        int right = s.length() - 1;
        while (left < right && s.charAt(left) == s.charAt(right)) {
            char current = s.charAt(left);
            while (left <= right && s.charAt(left) == current) {
                left++;
            }
            while (right >= left && s.charAt(right) == current) {
                right--;
            }
        }
        return right - left + 1;
    }
}

289th Problem
You are given an integer array nums and a positive integer k.
Return the number of subarrays where the maximum element of nums appears at least k times in that subarray.
A subarray is a contiguous sequence of elements within an array.
Example 1:
Input: nums = [1,3,2,3,3], k = 2
Output: 6
Explanation: The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].
Example 2:
Input: nums = [1,4,2,1], k = 3
Output: 0
Explanation: No subarray contains the element 4 at least 3 times.

class Solution {
    public long countSubarrays(int[] nums, int k) {
        long res = 0;
        int max = 0, count = 0, n = nums.length;
        for (int num : nums)
            max = Math.max(max, num);
        int l = 0;
        for (int r = 0; r < n; r++) {
            if (nums[r] == max)
                count++;
            while (count >= k) {
                res += n - r;
                if (nums[l] == max)
                    count--;
                l++;
            }
        }
        return res;
    }
}

290th Problem
Given an integer array nums and an integer k, return the number of good subarrays of nums.
A good array is an array where the number of different integers in that array is exactly k.
For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.
A subarray is a contiguous part of an array.
Example 1:
Input: nums = [1,2,1,2,3], k = 2
Output: 7
Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]
Example 2:
Input: nums = [1,2,1,3,4], k = 3
Output: 3
Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].

class Solution {
    public int subarraysWithKDistinct(int[] nums, int k) {
        int n = nums.length;
        int i = 0;
        int j = 0;
        int count = 0;
        int ans = 0;
        int []arr = new int[n + 1];
        while(j < n){
            arr[nums[j]]++;
            if(arr[nums[j]] == 1){
                count++;
            }
            while(count > k){
                arr[nums[i]]--;
                if(arr[nums[i]] == 0){
                    count--;
                }
                i++;
            }
            if(count == k){
                int val = i;
                while(count == k){
                    ans++;
                    int num = nums[val];
                    arr[num]--;
                    if(arr[num] == 0){
                        count--;
                    }
                    val++;
                }
                val--;
                while(val >= i){
                    int num = nums[val];
                    arr[num]++;
                    if(arr[num] == 1){
                        count++;
                    }
                    val--;
                } 
            }
            j++;
        }
        return ans;
    }
}

291st Problem
You are given an integer array nums and two integers minK and maxK.
A fixed-bound subarray of nums is a subarray that satisfies the following conditions:
The minimum value in the subarray is equal to minK.
The maximum value in the subarray is equal to maxK.
Return the number of fixed-bound subarrays.
A subarray is a contiguous part of an array.
Example 1:
Input: nums = [1,3,5,2,7,5], minK = 1, maxK = 5
Output: 2
Explanation: The fixed-bound subarrays are [1,3,5] and [1,3,5,2].
Example 2:
Input: nums = [1,1,1,1], minK = 1, maxK = 1
Output: 10
Explanation: Every subarray of nums is a fixed-bound subarray. There are 10 possible subarrays.

class Solution {
    public long countSubarrays(int[] nums, int minK, int maxK) {
        int minI = -1, maxI = -1, left = -1, right = 0;
        long count = 0;
        while(right < nums.length){
            if(nums[right] < minK || nums[right] > maxK){
                minI = right;
                maxI = right;
                left = right;
            }
            minI = nums[right] == minK ? right : minI;
            maxI = nums[right] == maxK ?  right : maxI;
            count += Math.min(minI, maxI) - left;
            right++;
        }
        return count;
    }
}

292nd Problem
Given two strings s and t, determine if they are isomorphic.
Two strings s and t are isomorphic if the characters in s can be replaced to get t.
All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.
Example 1:
Input: s = "egg", t = "add"
Output: true
Example 2:
Input: s = "foo", t = "bar"
Output: false
Example 3:
Input: s = "paper", t = "title"
Output: true

class Solution {
    public boolean isIsomorphic(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        int l = s.length();
        int[] map1 = new int[256];
        int[] map2 = new int[256];
        for (int i = 0; i < l; i++) {
            char ch1 = s.charAt(i);
            char ch2 = t.charAt(i);
            if (map1[ch1]>0) {
                if (map1[ch1] != ch2) {
                    return false;
                } 
            } else {
                if (map2[ch2]==1) {
                    return false;
                } else {
                    map1[ch1]=ch2;
                    map2[ch2]=1;
                }
            }
        }
        return true;
    }
}

293rd Problem
Mary has the result of test conducted in her subject English in the form of a list. She wants to reward the student who has got highest marks. Your task is to help Mary find the highest marks.
case=1
input=8
2 45 8 11 17 28 31 5
output=45	
Explanation:
Input: line one is number of elements in list, followed by their values, 
followed by the target element.
Output: 45, the largest element in the list.

import java.util.*;
class Solution {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int max=arr[0]; 
        for(int i=0;i<n;i++){
            if(arr[i]>max){
                max = arr[i];
            }
        }
        System.out.println(max);
    }
}

294th Problem
Joe is having a list of elements; he wants to reverse the list of elements. Your task is to help Joe with his task.
case=1
input=4
2 5 3 1
output=[1, 3, 5, 2]
Explanation:
Input: line one is number of elements in list, followed by their values 
Output: list in reverse order

import java.util.*;
class Solution {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        ArrayList<Integer> al = new ArrayList<Integer>();
        for(int i=n-1;i>=0;i--){
            al.add(arr[i]);
        }
        System.out.print(al);
    }
}

295th Problem
Mark is a student of 5th grade. His teacher Rebecca gives him a list of elements and asks him to check whether the elements in the list are in ascending order. He has to return true if the list is in ascending order, else return false. Your task is to help Mark in his task.case=1input=42 5 10 15output=trueExplanation:Input: line one is number of elements in list, followed by their values Output:true, since the elements are in ascending order

import java.util.*;
class Solution{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int flag=1;
        for(int i=0;i<n-1;i++){
             if(arr[i]>arr[i+1]){
                flag=0;
                break;
            }
        }
        if(flag==1){
            System.out.println("true");
        }
        else {
        System.out.println("false");
      }
    }
}

296th Problem
Stephen is a student of 6th grade. His teacher Jane gives him a list of elements and asks him to check whether the elements in the list are either in ascending or descending order. He has to return 1 when the list is ascending order, 2 for descending order, 0 for neither ascending or descending order. Your task is to help Stephen in his task.
case=1
input=4
2 5 10 15 
output=1	
Explanation:
Input: line one is number of elements in list, followed by their values 
Output: 1, the list is in ascending order
case=2
input=4
2 5 15 10 
output=0
Explanation:
Input: line one is number of elements in list, followed by their values 
Output:1, the list is neither in ascending nor descending order
case=3
input=3
8 4 1
output=2
Explanation:
Inpu:t line one is number of elements in list, followed by their values 
Output: 1, the list is in descending order

import java.util.*;
class Solution {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int asc=1,des=1;
        for(int i=0;i<n-1;i++){
            if(arr[i]<arr[i+1]){
                des=0;
            }else{
                asc=0;
            }
        }
        if(asc==1){
            System.out.println("1");
        }
        else if(des==1){
            System.out.println("2");
        }
        else{
            System.out.println("0");
        }
    }
}

297th Problem
Imagine you are developing a student grading system for a school,
where each student's scores in a particular subject are stored in 
an array. 
-To generate meaningful reports and analyze student 
 performance, it's essential to sort these scores in ascending order.
-Your task is to implement a feature that sorts the scores in ascending 
 order.
Input Format:
Line-1:Integer N
Line-2:Space seperated integers
Output Format:
Print the array
Sample Testcase:1
input=6
-5 -9 8 12 1 3 
output=-9 -5 1 3 8 12

import java.util.*;
class Solution {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
       for(int i=0;i<n-1;i++){
           for(int j=i+1;j<n;j++){
               if(arr[i]>arr[j])
               {
               int temp;
               temp=arr[i];
               arr[i] = arr[j];        // Bubble Sort
               arr[j] = temp;
               }
           }
       }
       for(int i=0;i<n;i++){
           System.out.print(arr[i]+ " ");
       }
    }
}

298th Problem
Consider a scenario where you are developing a quiz platform for students. Each quiz question has multiple-choice answers,and the student's response to each question is stored in an array. 
-Your task is to compare the student's response array with the correct answer array to determine if the student answered the questions correctly or not.
Note: If there are repetitions, then counts of repeated answers should be the same for two arrays to be equal.
Input Format:
Line-1:Space seperated integers
Line-2&3:Array elements
Output Format:
Boolen value
Sample Testcase:1
Sample Testcase:1
input=5 5
1 2 3 4 5
1 2 3 4 5
output=Yes

import java.util.*;
class Solution {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n1 = sc.nextInt();
        int n2 = sc.nextInt();
        int arr1[] = new int[n1];
        int arr2[] = new int[n2];
        for(int i=0;i<n1;i++){
            arr1[i] = sc.nextInt();
        }
        for(int i=0;i<n2;i++){
            arr2[i] = sc.nextInt();
        }
        int flag = 1;
        if(n1!=n2){
            flag = 0;
            System.out.println("No");
        }
        for(int i=0;i<n1;i++){
            if(arr1[i] != arr2[i]){
                flag=0;
                System.out.println("No");
                break;
            }
        }
        if(flag==1){
            System.out.println("Yes");
        }
    }
}

299th Problem
Imagine you're building a scheduling application for a company's 
shift management system. Each employee's shift schedule is 
stored in an array of integers, where each element represents
the employee's shift for a particular day. 
-Your task is to implement a feature that allows rotating the shift schedule to the left by a specified number of positions,accommodating changes in employee availability or preferences.
Sample Testcase:1
input=4
7 8 9 10
3
output=10 7 8 9

import java.util.*;
class Solution {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int k = sc.nextInt();
        for(int i=k;i<n;i++){
            System.out.println(arr[i]+" ");
        }
        for(int i=0;i<k;i++){
            System.out.println(arr[i]+" ");
        }
    }
}

300th Problem
Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
Example 1:
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true
Example 2:
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
Output: true
Example 3:
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
Output: false

class Solution {
    public boolean exist(char[][] board, String word) {
        int m = board.length, n = board[0].length;
        if(m*n < word.length()) return false;
        char[] wrd = word.toCharArray();
        int[] boardd = new int[128];
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                ++boardd[board[i][j]];
            }
        }
        for(char ch:wrd){
            if(--boardd[ch] < 0) return false;
        }
        if(boardd[wrd[0]] > boardd[wrd[wrd.length-1]]) reverse(wrd);
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                if(wrd[0] == board[i][j] && found(board, i, j, wrd, new boolean[m][n], 0)) return true;
            }
        }
        return false;
    }
    private void reverse(char[] word){
        int n = word.length;
        for(int i=0; i<n/2; ++i){
            char temp = word[i];
            word[i] = word[n-i-1];
            word[n-i-1] = temp;
        }
    }
    private static final int[] dirs = {0, -1, 0, 1, 0};
    private boolean found(char[][] board, int row, int col, char[] word, boolean[][] visited, int index){
        if(index == word.length) return true;
        if(row<0 || col<0 || row == board.length || col == board[0].length || board[row][col] != word[index] || visited[row][col]) return false;
        visited[row][col] = true;
        for(int i=0; i<4; ++i){
            if(found(board, row+dirs[i], col+dirs[i+1], word, visited, index+1)) return true;
        }
        visited[row][col] = false;
        return false;
    }
}

301st Problem
Imagine you are developing an inventory management system for 
a warehouse. The warehouse receives shipments of products in bulk, 
and each product is assigned a unique identifier represented by 
integers in an array. However, due to data entry errors or duplicate
shipments, the array may contain duplicate product identifiers.
-Your task is to remove these duplicates from the array in-place and 
 then print the number of unique products available in the inventory.
Input Format:
Line-1: Size of array
line-2: Array elements
Output Format:
Print unique products
Sample Testcase:1
input=3
1 1 2
output=1 2

import java.util.*;
class Solution {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        Set<Integer> s = new HashSet<>();
        for(int i=0;i<n;i++){
            s.add(arr[i]);
        }
        for(int ele:s){
            System.out.println(s);
        }
    }
}

302nd Problem
An automobile company manufactures both a two wheeler (TW) and a four wheeler(FW). 
A company manager wants to make the production of both types of vehicle
according to the given data below:
1st data, Total number of vehicle (two-wheeler + four-wheeler)=v
2nd data, Total number of wheels = W
The task is to find how many two-wheelers as well as four-wheelers need to
manufacture as per the given data.
Note:Print “INVALID INPUT” , if inputs did not meet the constraints.
Input Format
First Input line – Accept value of V.
Second Input line- Accept value for W.
Output Format
Integer or Print “INVALID INPUT” , if inputs did not meet the constraints.
Sample Testcase:1
Input=200 540  -> Value of V&W
Output=130 70
Explanation:
130+70 = 200 vehicles
(70*4)+(130*2)= 540 wheels
Constraints :
2<=W
W%2=0
V<W

import java.util.*;
class Solution {
    public static void main (String[] args) {
    Scanner sc = new Scanner(System.in);
    int v = sc.nextInt();
    int w = sc.nextInt();
    //x+y=v
    //2x+4y=w;
    if(v<w && w%2==0 && 2<=w)
    {
        int ans = (w-2*v)/2;
        System.out.println(v-ans+" "+ans);
    }
    else {
        System.out.print("INVALID INPUT");
    }   
  }
}

303rd Problem
A parking lot in a mall has RxC number of parking spaces. 
Each parking space will either be  empty(0) or full(1). 
The status (0/1) of a parking space is represented as the element of the matrix.
The task is to find index of the row(R) in the parking lot that has the most 
of the parking spaces full(1).
Note : RxC- Size of the matrix
Elements of the matrix M should be only 0 or 1.
Sample Testcase:1
Input=3 3
0 1 0
1 1 0 
1 1 1 
output=3  
Explanation:
Row 3 has maximum number of 1’s

import java.util.*;
class Solution{
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int r = sc.nextInt();
        int c = sc.nextInt();
        int arr[][] = new int[r][c];
        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                arr[i][j] = sc.nextInt();
            }
        }
        int k=0;
        int max=Integer.MIN_VALUE;
        for(int i=0;i<r;i++){
            int sum=0; // this value keeps on changing, so kept outside
            for(int j=0;j<c;j++){
                sum = sum+arr[i][j];
                if(sum>max){
                    max = sum;
                    k=i;
                }
            }
        }
        System.out.println(k+1);
    }
}

304th Problem
Given an integer array Arr of size N the task is to find the count 
of elements whose value is greater than all of its prior elements.
Note : 1st element of the array should be considered in the count of the result.
Sample Testcase:1
input=5
7 4 8 2 9
output=3
Explanation:
As 7 is the first element, it will consider in the result.
8 and 9 are also the elements that are greater than all of its previous elements.
Since total of  3 elements is present in the array that meets the condition.
Hence the output = 3.
5 -> Value of N, represents size of Arr
7-> Value of Arr[0]
4 -> Value of Arr[1]
8-> Value of Arr[2]
2-> Value of Arr[3]
9-> Value of Arr[4]
Output=3
Sample Testcase:2
input=5
3 4 5 8 9
output=5
Explanation:
5   -> Value of N, represents size of Arr
3  -> Value of Arr[0]
4 -> Value of Arr[1]
5 -> Value of Arr[2]
8 -> Value of Arr[3]
9 -> Value of Arr[4]
Output : 
5
Constraints
1<=N<=20
1<=Arr[i]<=10000

import java.util.*;
class Solution {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
     int n = sc.nextInt();
     int arr[] = new int[n];
     for(int i=0;i<n;i++){
         arr[i] = sc.nextInt();
     }
     int max=arr[0];
     int count=1;
     for(int i=0;i<n;i++){
         if(arr[i]>max){
             max=arr[i];
             count++;
         }
     }
     System.out.println(count);
    }
}

305th Problem
Imagine you are developing a task management system for a team,
where each task is represented by an integer identifier in an array. 
Sometimes, tasks are completed or cancelled and need to be removed 
from the system. 
-Your task is to implement a feature that removes 
 all occurrences of a specific task identifier (val) from the 
 array in-place and returns the count of remaining active tasks.
Sample Testcase:1
input=4
3 2 2 3
3
output=2

import java.util.*;
class Solution {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int count=0;
        int val = sc.nextInt();
        for(int i=0;i<n;i++){
            if(arr[i]==val){
                count++;
            }
        }
        System.out.println(n-count);
    }
}

306th Problem
A string is a valid parentheses string (denoted VPS) if it meets one of the following:
It is an empty string "", or a single character not equal to "(" or ")",
It can be written as AB (A concatenated with B), where A and B are VPS's, or
It can be written as (A), where A is a VPS.
We can similarly define the nesting depth depth(S) of any VPS S as follows:
depth("") = 0
depth(C) = 0, where C is a string with a single character not equal to "(" or ")".
depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's.
depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
For example, "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.
Given a VPS represented as string s, return the nesting depth of s.
Example 1:
Input: s = "(1+(2*3)+((8)/4))+1"
Output: 3
Explanation: Digit 8 is inside of 3 nested parentheses in the string.
Example 2:
Input: s = "(1)+((2))+(((3)))"
Output: 3

class Solution {
    public int maxDepth(String s) {
        int count=0,max=0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='(') count++;
            max=Math.max(count,max);
            if(s.charAt(i)==')') count--;
        }
        return max;
    }
}

307th Problem
John is provided with two list of elements; he is told by him manager to merge 
the elements from the two list into one list. Your task is to help John in his 
task.
Note: Use only arrays, no collections classes
case=1
input=3
10 12 15
4
103 125 134 62
output=[10, 12, 15, 103, 125, 134, 62]
Explanation:
Input: line one is number of elements in list1, followed by their values, 
followed by number of elements in list2, followed by their values. 
Output: is the merged list having both list1 and list2

import java.util.*;
class Solution {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n1 = sc.nextInt();
        int arr1[] = new int[n1];
        for(int i=0;i<n1;i++){
            arr1[i] = sc.nextInt();
        }
        int n2 = sc.nextInt();
        int arr2[] = new int[n2];
        for(int i=0;i<n2;i++){
            arr2[i] = sc.nextInt();
        }
        int n3=n1+n2;
        int c=0;
        int arr3[] = new int[n3];
       for(int i=0;i<n1;i++){
           arr3[c++]=arr1[i];
       }
       for(int i=0;i<n2;i++){
           arr3[c++]=arr2[i];
       }
       for(int i=0;i<n3;i++){
           System.out.println(arr3[i]);
       }
    }
}

308th Problem
Joe is having a string; he wants to find out whether the string is a palindrome. Your task is to help Joe in his task.
case=1
input=madam
output=true
Explanation:
Input: line one is string.
Output: true, the string is a palindrome

import java.util.*;
class Solution {
    public static boolean pal(String str){
        // if(str.length()==1){
        //     return true;
        // }
        // else{
        //     if(str.charAt(0)==str.charAt(str.length()-1)){
        //         return pal(str.substring(1,str.length()-1));
        //     }
        //     return false;
        // }
        int lp=0;
        int rp=str.length()-1;
        boolean ispal = true;
        while(lp<=rp){
            if(str.charAt(lp)!=str.charAt(rp)){
                ispal = false;
                break;
            } else {
                lp++;
                rp--;
            }
            return ispal;
        }
        return ispal;
    }
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        System.out.print(pal(str));
    }
}

309th Problem
Molly is given a list of elements sorted in ascending order and a target value. 
She wants to find whether the target is present in the list. Your task is to 
help Molly in her task.
case=1
input=8
2 5 8 11 17 28 31 45
28
output=5	
Explanation:
Input: line one is number of elements in list, followed by their values, 
followed by the target element.
Output: 5, the index of found element in the list.

import java.util.*;
class Solution {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int search = sc.nextInt();
        int low=0;
        int high=n-1;
        int a=0;
        while(low<=high){
        int mid=low+((high-low)/2);
         if(arr[mid]==search){
             System.out.print(mid);
             a++;
             break;
         }
         else if(arr[mid]<search){
             low=mid+1;
         }
         else{
             high=mid-1;
         }
       }
       if(a==0) System.out.print(-1);
    }
}

310th Problem
Alex has a string s1 and Martha has a string s2. Alex wants to know whether 
the string s1 is a part of s2. If yes, then he wants to know the index at which 
s1 occurs in S, else it should return -1. Your task is to help Alex in his task.
Note: Do not use build-in indexOf() method of String class.
case=1
input=lo hello
output=3
Explanation:
Input line one is string s1 followed by string s2
Output=3, the starting location of s1 in s2

import java.util.*;
public class SubstringIndex {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s1 = scanner.next();
        String s2 = scanner.next();
        int index = findSubstringIndex(s1, s2);
        System.out.println(index);
    }
    public static int findSubstringIndex(String s1, String s2) {
        int s1Length = s1.length();
        int s2Length = s2.length();   
        for (int i = 0; i <= s2Length - s1Length; i++) {
            int j;
            for (j = 0; j < s1Length; j++) {
                if (s2.charAt(i + j) != s1.charAt(j)) {
                    break;
                }
            }
            if (j == s1Length) {
                return i;
            }
        }
        return -1;
    }
}

311th Problem
Mary and John each have an integer array nums1 and nums2 respectively, sorted 
in ascending order. Peter wants to join these two arrays into single array 
sorted in ascending order. Peter does not want to have a separate array for the 
result and wants to use Mary’s integer array nums1 for the join. To accommodate 
this, nums1 has a length of m + n, where the first m elements denote the 
elements that should be joined, and the last n elements are set to 0 and should 
be ignored. nums2 has length of n. Your task is to help Peter in his task.
Sample test case
case=1
input=6
3
1 2 3 0 0 0
3
2 5 6
output=[1, 2, 2, 3, 5, 6]
Explanation: Line1 is the number of combined elements of both nums1 and nums2, 
followed by number elements of nums1 (i.e. m), followed by values of nums1, 
followed by number of elements of nums2 (i.e. n), followed by values of nums2.

import java.util.Arrays;
import java.util.Scanner;
public class MergeSortedArrays {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the number of elements in nums1: ");
        int m = scanner.nextInt();
        int[] nums1 = new int[m];
        System.out.println("Enter the elements of nums1:");
        for (int i = 0; i < m; i++) {
            nums1[i] = scanner.nextInt();
        }
        System.out.print("Enter the number of elements in nums2: ");
        int n = scanner.nextInt();
        int[] nums2 = new int[n];
        System.out.println("Enter the elements of nums2:");
        for (int i = 0; i < n; i++) {
            nums2[i] = scanner.nextInt();
        }
        merge(nums1, m, nums2, n);
        System.out.println("Merged sorted array: " + Arrays.toString(nums1));
    }
    public static void merge(int[] nums1, int m, int[] nums2, int n) {
        int index1 = m - 1;
        int index2 = n - 1;
        int mergedIndex = m + n - 1;
        while (index1 >= 0 && index2 >= 0) {
            if (nums1[index1] > nums2[index2]) {
                nums1[mergedIndex] = nums1[index1];
                index1--;
            } else {
                nums1[mergedIndex] = nums2[index2];
                index2--;
            }
            mergedIndex--;
        }
        while (index2 >= 0) {
            nums1[mergedIndex] = nums2[index2];
            index2--;
            mergedIndex--;
        }
    }
}

312th Problem
Given a string s of lower and upper case English letters.
A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where:
0 <= i <= s.length - 2
s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.
To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.
Return the string after making it good. The answer is guaranteed to be unique under the given constraints.
Notice that an empty string is also good.
Example 1:
Input: s = "leEeetcode"
Output: "leetcode"
Explanation: In the first step, either you choose i = 1 or i = 2, both will result "leEeetcode" to be reduced to "leetcode".
Example 2:
Input: s = "abBAcC"
Output: ""
Explanation: We have many possible scenarios, and all lead to the same answer. For example:
"abBAcC" --> "aAcC" --> "cC" --> ""
"abBAcC" --> "abBA" --> "aA" --> ""

class Solution {
    public String makeGood(String s) {
        int n = s.length();
        StringBuilder sb = new StringBuilder();
        for(char curr : s.toCharArray()){
            char peek = sb.length() > 0 ? sb.charAt(sb.length() - 1) : '1';
            if(Math.abs(peek - curr) == 32  && sb.length() > 0){
                sb.deleteCharAt(sb.length() - 1);
            }else{
                sb.append(curr);
            }
        }
        return sb.toString();
    }
}

313rd Problem
Given the root of a binary tree, return the sum of all left leaves.
A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.
Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: 24
Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.
Example 2:
Input: root = [1]
Output: 0

class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        int sum=0;
        if(root==null) return 0;
        if(root.left!=null && root.left.left==null && root.left.right==null) sum+=root.left.val;
        sum+=sumOfLeftLeaves(root.left);
        sum+=sumOfLeftLeaves(root.right);
        return sum;
    }
}

314th Problem
There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.
You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].
Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.
Return the time taken for the person at position k (0-indexed) to finish buying tickets.
Example 1:
Input: tickets = [2,3,2], k = 2
Output: 6
Explanation: 
- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].
- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].
The person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.
Example 2:
Input: tickets = [5,1,1,1], k = 0
Output: 8
Explanation:
- In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].
- In the next 4 passes, only the person in position 0 is buying tickets.
The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.

class Solution {
public int timeRequiredToBuy(int[] tickets, int k) {
        int time = 0;
        for (int i = 0; i < tickets.length; i++) {
            if (tickets[i] >= tickets[k] && i <= k) {
                time += tickets[k];
            } else if (tickets[i] < tickets[k] && i < k) {
                time += tickets[i];
            } else if (tickets[i] >= tickets[k] && i > k) {
                time += tickets[k]-1;
            } else if (tickets[i] < tickets[k] && i > k) {
                time += tickets[i];
            }
        }
        return time;
    }
}

315th Problem
You are given the root of a binary tree containing digits from 0 to 9 only.
Each root-to-leaf path in the tree represents a number.
For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.
A leaf node is a node with no children.
Example 1:
Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
Example 2:
Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.

class Solution {
    public int sumTree(TreeNode root,int sum){
        if(root==null) return 0;
        sum=sum*10+root.val;
        if(root.left==null && root.right==null) return sum;
        return sumTree(root.left,sum)+sumTree(root.right,sum);
    }
    public int sumNumbers(TreeNode root) {
                return sumTree(root,0);
    }
}

316th Problem
Alex is having a list of integers. He wants to find the median of the elements in the list. Your task is to help Alex in his task.
case=1
input=7
2 3 4 1 5 6 7
output=4.0
case=2
input=4
3 4 1 2
output=2.5

import java.util.*;
class Solution {
    public static float median(int n,int arr[]){
        Arrays.sort(arr);
        if(n%2==0){
            float ans=arr[(n/2)-1] + arr[(n/2)];
            return ans/2;
        }
        else{
            return arr[n/2];
        }
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        System.out.println((float)median(n,arr));
    }
}

317th Problem
Alex is having a list of integers. He wants to find the first missing positive 
integer in the list. If he finds there are no missing positive integer, then he 
has to find the number that is to added. Your task is to help Alex in his task.
case=1
input=4
3 4 -1 1
output=2
case=2
input=3
1 2 0
output=3

import java.util.*;
class Solution {
    public static int miss(int n,int arr[]){
        Arrays.sort(arr);
        for(int i=0;i<n-1;i++){
            if(arr[i]>0){
                if(arr[i+1]!=(arr[i]+1)){
                    return arr[i]+1;
                }
                else{
                    continue;
                }
            }
        }
        return arr[n-1]+1;
    }
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        System.out.println(miss(n,arr));
    }
}

318th Problem
Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth. Note that the root node is at depth 1. The adding rule is:
Given the integer depth, for each not null tree node cur at the depth depth - 1, create two tree nodes with value val as cur's left subtree root and right subtree root.
cur's original left subtree should be the left subtree of the new left subtree root.
cur's original right subtree should be the right subtree of the new right subtree root.
If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root's left subtree.
Example 1:
Input: root = [4,2,6,3,1,5], val = 1, depth = 2
Output: [4,1,1,2,null,null,6,3,1,5]
Example 2:
Input: root = [4,2,null,3,1], val = 1, depth = 3
Output: [4,2,null,1,1,3,null,null,1]

class Solution {
    public TreeNode addOneRow(TreeNode root, int val, int depth) {
        if(root==null)
            return root;
        if(depth==1){
            TreeNode l = new TreeNode(val, root.left, null);
            l.left = root;
            return l;
        }
        if(depth==2){
            TreeNode l = new TreeNode(val, root.left, null);
            root.left = l;
            TreeNode r = new TreeNode(val, null, root.right);
            root.right = r;
            return root;
        }
        root.left = addOneRow(root.left, val, depth-1);
        root.right = addOneRow(root.right, val, depth-1);
        return root;
    }
}

319th Problem
You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.Return the lexicographically smallest string that starts at a leaf of this tree and ends at the root. As a reminder, any shorter prefix of a string is lexicographically smaller.
For example, "ab" is lexicographically smaller than "aba".
A leaf of a node is a node that has no children.
Example 1:
Input: root = [0,1,2,3,4,3,4]
Output: "dba"
Example 2:
Input: root = [25,1,3,1,3,0,2]
Output: "adz"
Example 3:
Input: root = [2,2,1,null,1,0,null,0]
Output: "abc"

class Solution {
    String smallestString = "~"; // Initialize with a value that will be replaced
    public String smallestFromLeaf(TreeNode root) {
        dfs(root, new StringBuilder());
        return smallestString;
    }
    private void dfs(TreeNode node, StringBuilder path) {
        if (node == null) {
            return;
        }   
        path.append((char)('a' + node.val)); // Convert node value to character and append to path
        if (node.left == null && node.right == null) { // Check if it's a leaf node
            String currentString = path.reverse().toString(); // Reverse path to get the string from leaf to root
            if (currentString.compareTo(smallestString) < 0) { // Compare with current smallest string
                smallestString = currentString;
            }
            path.reverse(); // Reverse back for backtracking
        }
        dfs(node.left, path); // Traverse left subtree
        dfs(node.right, path); // Traverse right subtree
        path.deleteCharAt(path.length() - 1); // Backtrack: remove last character
    }
}

320th Problem
Peter is having a list of integers. He was to store the sum all the previous numbers to each index in the array. Your task is to help Peter in his task.
case=1
input=7
1 2 3 4 5 6 7
output=[1, 3, 6, 10, 15, 21, 28]

import java.util.*;
class Solution {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int sum=0;
        for(int i=0;i<n;i++){
            sum=sum+arr[i];
            arr[i]=sum;
        }
        ArrayList <Integer> al = new ArrayList<>();
        for(int i=0;i<n;i++){
            al.add(arr[i]);
        }
        System.out.println(al);
    }
}

321st Problem
James is given an matrix of m*n dimension. He is told that the values in matrix 
should follow below condition.Each pair of values in the 1st row should be in ascending order, similarly each pair of values in the next row should be in descending order, this pattern of 
ascending order followed by descending order is repeated for alternate rows. 
James has to find out the number of pairs that do not follow this condition. 
Your task is to help James in his task.
case=1
input=4 4
1 3 4 2
5 4 2 3
4 2 1 3
6 4 2 3
output=8
Explanation:
1st row (ascending) = (3,2), (4,2)
2nd row (descending) = (2,3)
3rd row (ascending) = (4,2), (4,1) (4,3), (2,1)
4th row (descending) = (2,3)

import java.util.*;
class Solution {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int r = sc.nextInt();
        int c = sc.nextInt();
        int arr[][] = new int[r][c];
        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                arr[i][j]=sc.nextInt();
            }
        }
        int count=0;
        for(int i=0;i<r;i++){
            for(int j=0;j<c-1;j++){
                for(int k=j+1;k<c;k++){
                    if(i%2==0 && arr[i][j] > arr[i][k] || i%2!=0 && arr[i][j] < arr[i][k]){
                        count++;
                    }
                }
            }
        }
        System.out.println(count);
    }
}

322nd Problem
John wants to find the nth term of a given series. The series starts with zero 
and one as the first two elements respectively. The value for any other term is 
the sum of its previous two terms. Given a number n, help John find the value 
of the nth term.
Note: You must use only recursive approach
input=2
output=1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.
input=3
output=2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.

import java.util.*;
class Solution {
    public static int nterm(int n){
        if(n==0) return 0;
        else if(n==1) return 1;
        else return nterm(n-1)+nterm(n-2);
    }
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.println(nterm(n));
    }
}

323rd Problem
Molly gives an integer n to her friend Rebecca and ask her to find if n is a 
power of two. Rebecca has to return true if n is a power of two, otherwise she 
has to return false. An integer is power of two, if there exist an integer x 
such that n is equal to 2^x.
Note: Can you solve it without loops or recursion
Sample test case
case=1
input=4
output=true
case=3
input=0
output=false

import java.util.*;
class Solution {
    public static boolean power(int n){
        if(n==0) return false;
        if(n==1) return true;
        if(n%2==0){
            return power(n/2);
        }
        else{
            return false;
        }
    }
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.println(power(n));
    }
}

324th Problem
You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.
Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).
The island doesn't have "lakes", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.
Example 1:
Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
Output: 16
Explanation: The perimeter is the 16 yellow stripes in the image above.
Example 2:
Input: grid = [[1]]
Output: 4
Example 3:
Input: grid = [[1,0]]
Output: 4

class Solution {
    public int islandPerimeter(int[][] grid) {
        int length = grid.length;
        int length2 = grid[0].length;
        int sum = 0;
        for(int i = 0; i < length; i++) {
            for(int j = 0; j < length2; j++) {
                if(grid[i][j] == 1) {
                    sum+=4;
                    // check horizontally
                    if(j > 0 && grid[i][j-1] == 1) {
                        sum -=2;
                    }
                    // check vertically
                    if(i > 0 && grid[i-1][j] == 1) {
                        sum -=2;
                    }
                }
            }
        }
        return sum;
    }
}

325th Problem
Given a string s of '(' , ')' and lowercase English characters.
Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.
Formally, a parentheses string is valid if and only if:
It is the empty string, contains only lowercase characters, or
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.
Example 1:
Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
Example 2:
Input: s = "a)b(c)d"
Output: "ab(c)d"
Example 3:
Input: s = "))(("
Output: ""
Explanation: An empty string is also valid.

class Solution {
    public String minRemoveToMakeValid(String s) {
        char[] temp = s.toCharArray();
        int balance = 0;
        for (int i = 0; i < temp.length;i++) {
           if (temp[i] == ')') {
                if (balance - 1 < 0) {
                    temp[i] = '0';
                } else {
                    balance--;
                }
           } else if (temp[i] == '(') {
                balance++;
           }
        }
        int index = temp.length - 1;
        while (balance != 0 && index >= 0) {
            if (temp[index] == '(') {
                temp[index] = '0';
                balance--;
            }
            index--;
        }
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < temp.length;i++) {
            if (temp[i] != '0') {
                result.append(temp[i]);
            }
        }   
        return result.toString();
    }
}

326th Problem
There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. You want to determine if there is a valid path that exists from vertex source to vertex destination.Given edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.
Example 1:
Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
Output: true
Explanation: There are two paths from vertex 0 to vertex 2:
- 0 → 1 → 2
- 0 → 2
Example 2:
Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
Output: false
Explanation: There is no path from vertex 0 to vertex 5.

class Solution {
    public boolean validPath(int n, int[][] edges, int source, int destination) {
        if(edges.length == 0) return true;
        boolean[] visited = new boolean[n];
        boolean flag = true;
        visited[source] = true;
        while(flag){
            flag = false;
            for(int[] edge : edges){
                if(visited[edge[0]] != visited[edge[1]]){
                    visited[edge[0]] = true;
                    visited[edge[1]] = true;
                    flag = true;
                }
                if(visited[destination]) return true;
            }
        }
        return false;
    }
}

327th Problem
Bob is an expert in cryptography. His boss Alan gives him a string S in an 
encoded form and an integer array indices of string S length. He asks Bob to 
decode the String S by moving each character at ith position in S, to indices[i]
position in decoded string. Your task is to help Bob in his task.
case =1
input =aeilmmor
6 1 5 7 2 0 3 4
output =memorial
case =2
input =aidin
4 3 2 0 1
output =india

import java.util.*;
class Solution {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = "";
        String st[] = sc.nextLine().split("");
        String nu[] = sc.nextLine().split(" ");
        int[] n = new int[nu.length];
        for(int i=0;i<nu.length;i++){
        n[i] = Integer.parseInt(nu[i]);
        }
        for(int i=0;i<st.length;i++){
            for(int j=0;j<st.length;j++){
                if(i==n[j]){
                    System.out.print(st[j]);
                }
            }
        }
    }
}

328th Problem
John is having a string and wants to form consecutive groups of the same 
character. A group is identified by an interval, which is the start and end 
indices (inclusive) of the group. John is only interested in groups that has 3 
or more characters. Your task is to help John identify every interval of these groups in increasing
order by start index.
case=1
input=aabbbcc
output=[[2, 4]]
Explanation: The group having 3 or more consecutive characters is bbb and its 
interval is [2, 4]
case=2
input=aaaabccc
output=[[0, 3], [5, 7]]

import java.util.*;
class Solution {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        intervals(s);
    }
    public static void intervals(String s){
        List<List<Integer>> l = new ArrayList<>();
        int count = 0;
        int p1=0;
        int p2=0;
        while (p2 < s.length()){
            if (s.charAt(p1)==s.charAt(p2)){
                p2++;
                count++;
            } 
            else{
                if(count>=3){
                    List<Integer> temp = new ArrayList<>();
                    temp.add(p1);
                    temp.add(p2 - 1);
                    l.add(temp);
                }
                count=0;
                p1=p2;
            }
        }
        if(count>=3){
            List<Integer> temp = new ArrayList<>();
            temp.add(p1);
            temp.add(p2-1);
            l.add(temp);
        }
        System.out.println(l);
    }
}

329th Problem
You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.
You are given an integer array nums representing the data status of this set after the error.
Find the number that occurs twice and the number that is missing and return them in the form of an array.
Example 1:
Input: nums = [1,2,2,4]
Output: [2,3]
Example 2:
Input: nums = [1,1]
Output: [1,2]

class Solution {
    public int[] findErrorNums(int[] nums) {
        int[] ans = new int[2];
        int[] arr = new int[nums.length];
        for(int i = 0; i < nums.length; i++){
            arr[nums[i]-1] += 1;
        }
        for(int i = 0; i < arr.length; i++){
            if(arr[i] == 2) ans[0] = i+1;
            if(arr[i] == 0) ans[1] = i+1;
        }
        return ans;
    }
}

330th Problem
Given the root of a binary tree, return the inorder traversal of its nodes' values.
Example 1:
Input: root = [1,null,2,3]
Output: [1,3,2]
Example 2:
Input: root = []
Output: []
Example 3:
Input: root = [1]
Output: [1]

class Solution {
    List<Integer> list = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root==null) return new ArrayList<>();
        inorderTraversal(root.left);
        list.add(root.val);
        inorderTraversal(root.right);
        return list;
    }
}

331st Problem
Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.
Example 1:
Input: left = 5, right = 7
Output: 4
Example 2:
Input: left = 0, right = 0
Output: 0
Example 3:
Input: left = 1, right = 2147483647
Output: 0

class Solution {
    public int rangeBitwiseAnd(int left, int right) {
        int shift = 0;
        // Find the common prefix of binary representation
        while (left < right) {
            left >>= 1;
            right >>= 1;
            shift++;
        }
        // Shift back to obtain the final result
        return left << shift;
    }
}

332nd Problem
Given a container with N+1 balls with a number print on them.Numbers are between 0 to N, there is no repetition of numbers.A ball is missed from the container.Your task is to findout the ball, and return the number printed on it.
case=1
input=4
3 0 1 4
output=2
case=2
input=9
3 7 6 2 5 4 9 1 0 
output=8

import java.util.*;
class Solution {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        Arrays.sort(arr);
        for(int i=0;i<n;i++){
            if(arr[i]!=i){
                System.out.println(i);
            }
        }
    }
}

333rd Problem
There are a set of boxes and each box has a number.Rajiv arranged these set of boxes in an array. arr[i] is the number written on ith box. Your task is to return "true" if arr[i]==arr[j], otherwise return "false".
case=1
input=4
4 2 3 4 5
output=true
case=2
input=6
4 2 3 6 5 7
output=false

import java.util.*;
class Solution {
    public static boolean tof(int arr[],int n){
        for(int i=0;i<n;i++){
            for(int j= i + 1;j<n;j++){
                if(arr[i]==arr[j]){
                    return true;
                }
            }
        }
        return false;
    }
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        System.out.println(tof(arr,n));
    }
}

334th Problem
There are N persons in the room, each person is paired with other person except 
one. Every person is identified with an ID number, and every pair will have 
same ID number.
You will be given the ID's of N persons as a list[].
Your task is to find the person ID, who is not paired with anyone in the room.
Can you solve this problem in O(N) time complexity?
case=1
input=9
3 1 3 4 6 7 4 6 1
output=7

import java.util.*;
class Solution {
    public static int nopair(int arr[]){
        Map<Integer,Integer> m = new HashMap<>();
        for(int n:arr){
            if(m.containsKey(n)){
                m.put(n,m.get(n)+1);
            } else{
                m.put(n,1);
            }
        }
        for(int i=0;i<arr.length;i++){
         if(m.get(arr[i])==1){
             return arr[i];
         }
        }
        return -1;
    }
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        System.out.println(nopair(arr));
    }
}